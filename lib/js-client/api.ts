/* tslint:disable */
/* eslint-disable */
/**
 * AITRIOS | Console
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.4.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AWS
 */
export interface AWS {
    /**
     * Set the storage service type. Specify \"AWS\" as the value. - Value definition   AWS
     * @type {string}
     * @memberof AWS
     */
    'type': string;
    /**
     * Set the mode. Specifies the input image , inference result or both to be streamed. - Value definition   0 : input image only   1 : input image and inference result   2 : inference result only
     * @type {number}
     * @memberof AWS
     */
    'mode'?: number;
    /**
     * Destination AWS S3 endpoint.
     * @type {string}
     * @memberof AWS
     */
    'endpoint': string;
    /**
     * AWS Region. *Need to choose from the official list.
     * @type {string}
     * @memberof AWS
     */
    'region': string;
    /**
     * AWS S3 Bucket name.
     * @type {string}
     * @memberof AWS
     */
    'bucket_name': string;
    /**
     * AWS Secret Access key.
     * @type {string}
     * @memberof AWS
     */
    'secret_access_key': string;
    /**
     * AWS Access key ID.
     * @type {string}
     * @memberof AWS
     */
    'access_key_id': string;
}
/**
 * 
 * @export
 * @interface Azure
 */
export interface Azure {
    /**
     * Set the storage service type. Specify \"AZURE\" as the value. - Value definition   AZURE
     * @type {string}
     * @memberof Azure
     */
    'type'?: string;
    /**
     * Set the mode. Specifies the input image, inferences result or both to be streamed. - Value definition   0 : input image only   1 : input image and inference result   2 : inference result only
     * @type {number}
     * @memberof Azure
     */
    'mode'?: number;
    /**
     * Destination Azure Blob Storage endpoint. *Do not specify \"endpoint\", \"connection_string\", or \"container_name when returning to the initial value. In the case of the initial value when input image is specified in \"mode\", it will be streamed within this service and then when inference result is specified in \"mode\", The settings for inference are deleted.
     * @type {string}
     * @memberof Azure
     */
    'endpoint'?: string;
    /**
     * Connection string for Azure Blob Storage. *When initializing, see the description of \"endpoint\".
     * @type {string}
     * @memberof Azure
     */
    'connection_string'?: string;
    /**
     * Container name of Azure Blob Storage. *When initializing, see the description of \"endpoint\".
     * @type {string}
     * @memberof Azure
     */
    'container_name'?: string;
}
/**
 * BindCommandParameterFileToDevice Json Body
 * @export
 * @interface BindCommandParameterFileToDeviceJsonBody
 */
export interface BindCommandParameterFileToDeviceJsonBody {
    /**
     * Specify multiple device IDs separated by commas.
     * @type {string}
     * @memberof BindCommandParameterFileToDeviceJsonBody
     */
    'device_ids': string;
}
/**
 * ChangePassword API json_body
 * @export
 * @interface ChangePasswordJsonBody
 */
export interface ChangePasswordJsonBody {
    /**
     * Plaintext and max. *Max. 32 characters.
     * @type {string}
     * @memberof ChangePasswordJsonBody
     */
    'password': string;
}
/**
 * CreateFirmware API model
 * @export
 * @interface CreateFirmwareJsonBody
 */
export interface CreateFirmwareJsonBody {
    /**
     * Firmware type ID. - Value definition   00: MCU(AppFw)   01: IMX500(Sensor)   02: IMX500(SensorLoader)
     * @type {string}
     * @memberof CreateFirmwareJsonBody
     */
    'firmware_type': string;
    /**
     * Firmware version number.
     * @type {string}
     * @memberof CreateFirmwareJsonBody
     */
    'version_number': string;
    /**
     * Comment. *Max. 100 characters.
     * @type {string}
     * @memberof CreateFirmwareJsonBody
     */
    'comment'?: string;
    /**
     * Firmware filename
     * @type {string}
     * @memberof CreateFirmwareJsonBody
     */
    'file_name': string;
    /**
     * Firmware File (BASE64 encoding).
     * @type {string}
     * @memberof CreateFirmwareJsonBody
     */
    'file_content': string;
}
/**
 * CreateProjectImageRegions JsonBody.
 * @export
 * @interface CreateProjectImageRegionsJsonBody
 */
export interface CreateProjectImageRegionsJsonBody {
    /**
     * 
     * @type {Array<RegionsInner>}
     * @memberof CreateProjectImageRegionsJsonBody
     */
    'regions'?: Array<RegionsInner>;
}
/**
 * DeleteImages JsonBody.
 * @export
 * @interface DeleteImagesJsonBody
 */
export interface DeleteImagesJsonBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteImagesJsonBody
     */
    'filenames'?: Array<string>;
    /**
     * Set the directory deletion flg. - Value definition   0 : Delete by specifying a file   1 : Delete by specifying a directory 
     * @type {string}
     * @memberof DeleteImagesJsonBody
     */
    'directory_deletion'?: string;
}
/**
 * 
 * @export
 * @interface DeployConfiguration
 */
export interface DeployConfiguration {
    /**
     * Set the config ID.
     * @type {string}
     * @memberof DeployConfiguration
     */
    'config_id': string;
    /**
     * Set the device type.
     * @type {string}
     * @memberof DeployConfiguration
     */
    'device_type': string;
    /**
     * Set the config comment.
     * @type {string}
     * @memberof DeployConfiguration
     */
    'config_comment': string;
    /**
     * Set the running cnt.
     * @type {number}
     * @memberof DeployConfiguration
     */
    'running_cnt': number;
    /**
     * Set the success cnt.
     * @type {number}
     * @memberof DeployConfiguration
     */
    'success_cnt': number;
    /**
     * Set the fail cnt.
     * @type {number}
     * @memberof DeployConfiguration
     */
    'fail_cnt': number;
    /**
     * 
     * @type {DeployConfigurationFirmware}
     * @memberof DeployConfiguration
     */
    'firmware': DeployConfigurationFirmware;
    /**
     * 
     * @type {DeployConfigurationModel}
     * @memberof DeployConfiguration
     */
    'model': DeployConfigurationModel;
    /**
     * Set the deployment author.
     * @type {string}
     * @memberof DeployConfiguration
     */
    'ins_id': string;
    /**
     * Set the date the deployment was created.
     * @type {string}
     * @memberof DeployConfiguration
     */
    'ins_date': string;
    /**
     * Set the deployment updater.
     * @type {string}
     * @memberof DeployConfiguration
     */
    'upd_id': string;
    /**
     * Set the date the deployment was updated.
     * @type {string}
     * @memberof DeployConfiguration
     */
    'upd_date': string;
}
/**
 * 
 * @export
 * @interface DeployConfigurationFirmware
 */
export interface DeployConfigurationFirmware {
    /**
     * Set the sensor loader filename.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'sensor_loader_file_name'?: string;
    /**
     * Set the sensor loader version number.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'sensor_loader_version_number'?: string;
    /**
     * Set the sensor loader firmware comment.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'sensor_loader_firmware_comment'?: string;
    /**
     * Set the sensor filename.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'sensor_file_name'?: string;
    /**
     * Set the sensor version number.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'sensor_version_number'?: string;
    /**
     * Set the sensor firmware comment.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'sensor_firmware_comment'?: string;
    /**
     * Set the apfw filename.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'apfw_file_name'?: string;
    /**
     * Set the apfw version number.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'apfw_version_number'?: string;
    /**
     * Set the apfw firmware comment.
     * @type {string}
     * @memberof DeployConfigurationFirmware
     */
    'apfw_firmware_comment'?: string;
}
/**
 * 
 * @export
 * @interface DeployConfigurationModel
 */
export interface DeployConfigurationModel {
    /**
     * Set the model ID.
     * @type {string}
     * @memberof DeployConfigurationModel
     */
    'model_id'?: string;
    /**
     * Set the model version number.
     * @type {string}
     * @memberof DeployConfigurationModel
     */
    'model_version_number'?: string;
    /**
     * Set the model comment.
     * @type {string}
     * @memberof DeployConfigurationModel
     */
    'model_comment'?: string;
    /**
     * Set the model version comment.
     * @type {string}
     * @memberof DeployConfigurationModel
     */
    'model_version_comment'?: string;
}
/**
 * DeployDeviceApp Json Body
 * @export
 * @interface DeployDeviceAppJsonBody
 */
export interface DeployDeviceAppJsonBody {
    /**
     * App name.
     * @type {string}
     * @memberof DeployDeviceAppJsonBody
     */
    'app_name': string;
    /**
     * App version number.
     * @type {string}
     * @memberof DeployDeviceAppJsonBody
     */
    'version_number': string;
    /**
     * Specify multiple device IDs separated by commas.
     * @type {string}
     * @memberof DeployDeviceAppJsonBody
     */
    'device_ids': string;
    /**
     * Comment. *Max. 100 characters.
     * @type {string}
     * @memberof DeployDeviceAppJsonBody
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface DeployHistory
 */
export interface DeployHistory {
    /**
     * Deploy ID.
     * @type {number}
     * @memberof DeployHistory
     */
    'id': number;
    /**
     * Set the deploy type. - Value definition   0: Deploy config   1: Device Model   App: DeviceApp
     * @type {string}
     * @memberof DeployHistory
     */
    'deploy_type': string;
    /**
     * Set the deploy status. *Target device deployment status. - Value definition   0: Deploying   1: Success   2: Fail   3: Cancel   App: DeviceApp undeploy
     * @type {string}
     * @memberof DeployHistory
     */
    'deploy_status': string;
    /**
     * Set the update progress in percentage.
     * @type {string}
     * @memberof DeployHistory
     */
    'update_progress'?: string;
    /**
     * Set the deploy comment.
     * @type {string}
     * @memberof DeployHistory
     */
    'deploy_comment'?: string;
    /**
     * Set the deploy config ID.
     * @type {string}
     * @memberof DeployHistory
     */
    'config_id'?: string;
    /**
     * Set the replace network ID.
     * @type {string}
     * @memberof DeployHistory
     */
    'replace_network_id': string;
    /**
     * Set the current target.
     * @type {string}
     * @memberof DeployHistory
     */
    'current_target': string;
    /**
     * Set the deploy status. *Total status of devices deployed together. - Value definition   0: Deploying   1: Success   2: Fail   3: Cancel
     * @type {string}
     * @memberof DeployHistory
     */
    'total_status'?: string;
    /**
     * Set the app name.
     * @type {string}
     * @memberof DeployHistory
     */
    'app_name'?: string;
    /**
     * Set the version number.
     * @type {string}
     * @memberof DeployHistory
     */
    'version_number'?: string;
    /**
     * 
     * @type {DeployHistoryFirmware}
     * @memberof DeployHistory
     */
    'firmware': DeployHistoryFirmware;
}
/**
 * 
 * @export
 * @interface DeployHistoryFirmware
 */
export interface DeployHistoryFirmware {
    /**
     * Set the deploy target flg. - Value definition   0: Not for deployment   1: Deployment target
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_loader_target_flg'?: string;
    /**
     * Set the deploy status. - Value definition   0: Waiting   1: Deploying   2: Success   3: Fail
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_loader_status'?: string;
    /**
     * Set the sensor loader retry count.
     * @type {number}
     * @memberof DeployHistoryFirmware
     */
    'sensor_loader_retry_count'?: number;
    /**
     * Set the sensor loader start date.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_loader_start_date'?: string;
    /**
     * Set the sensor loader end date.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_loader_end_date'?: string;
    /**
     * Set the sensor loader version number.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_loader_version_number'?: string;
    /**
     * Set the sensor loader version comment.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_loader_version_comment'?: string;
    /**
     * Set the deploy target flg. - Value definition   0: Not for deployment   1: Deployment target
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_target_flg'?: string;
    /**
     * Set the deploy status. - Value definition   0: Waiting   1: Deploying   2: Success   3: Fail
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_status'?: string;
    /**
     * Set the sensor retry count.
     * @type {number}
     * @memberof DeployHistoryFirmware
     */
    'sensor_retry_count'?: number;
    /**
     * Set the sensor start date.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_start_date'?: string;
    /**
     * Set the sensor end date.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_end_date'?: string;
    /**
     * Set the sensor version number.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_version_number'?: string;
    /**
     * Set the sensor version comment.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'sensor_version_comment'?: string;
    /**
     * Set the deploy target flg. - Value definition   0: Not for deployment   1: Deployment target
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'apfw_target_flg'?: string;
    /**
     * Set the deploy status. - Value definition   0: Waiting   1: Deploying   2: Success   3: Fail
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'apfw_status'?: string;
    /**
     * Set the appfw retry count.
     * @type {number}
     * @memberof DeployHistoryFirmware
     */
    'apfw_retry_count'?: number;
    /**
     * Set the appfw start date.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'apfw_start_date'?: string;
    /**
     * Set the appfw end date.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'apfw_end_date'?: string;
    /**
     * Set the appfw version number.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'apfw_version_number'?: string;
    /**
     * Set the appfw version comment.
     * @type {string}
     * @memberof DeployHistoryFirmware
     */
    'apfw_version_comment'?: string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Set the device ID.
     * @type {string}
     * @memberof Device
     */
    'device_id': string;
    /**
     * Set the location.
     * @type {string}
     * @memberof Device
     */
    'place'?: string;
    /**
     * Set the device description.
     * @type {string}
     * @memberof Device
     */
    'comment'?: string;
    /**
     * 
     * @type {DeviceProperty}
     * @memberof Device
     */
    'property'?: DeviceProperty;
    /**
     * Set the device type.
     * @type {string}
     * @memberof Device
     */
    'device_type'?: string;
    /**
     * Set the display device type.
     * @type {string}
     * @memberof Device
     */
    'display_device_type'?: string;
    /**
     * Set the device author.
     * @type {string}
     * @memberof Device
     */
    'ins_id': string;
    /**
     * Set the date the device was created.
     * @type {string}
     * @memberof Device
     */
    'ins_date': string;
    /**
     * Set the device updater.
     * @type {string}
     * @memberof Device
     */
    'upd_id': string;
    /**
     * Set the date the device was updated.
     * @type {string}
     * @memberof Device
     */
    'upd_date': string;
    /**
     * Set the device connection state.
     * @type {string}
     * @memberof Device
     */
    'connectionState': string;
    /**
     * Set the date the device last connected.
     * @type {string}
     * @memberof Device
     */
    'lastActivityTime': string;
    /**
     * 
     * @type {Array<DeviceModelsInner>}
     * @memberof Device
     */
    'models'?: Array<DeviceModelsInner>;
    /**
     * 
     * @type {Array<DeviceDeviceGroupsInner>}
     * @memberof Device
     */
    'device_groups'?: Array<DeviceDeviceGroupsInner>;
    /**
     * 
     * @type {object}
     * @memberof Device
     */
    'configuration'?: object;
    /**
     * 
     * @type {object}
     * @memberof Device
     */
    'state'?: object;
    /**
     * 
     * @type {Array<DeviceCommandResultsInner>}
     * @memberof Device
     */
    'command_results'?: Array<DeviceCommandResultsInner>;
    /**
     * 
     * @type {Array<DeviceAppsInner>}
     * @memberof Device
     */
    'apps'?: Array<DeviceAppsInner>;
}
/**
 * 
 * @export
 * @interface DeviceApp
 */
export interface DeviceApp {
    /**
     * Set the app name.
     * @type {string}
     * @memberof DeviceApp
     */
    'name'?: string;
    /**
     * Set the create_by. - Value definition   Self: Self-training models   Marketplace: Marketplace purchacing model 
     * @type {string}
     * @memberof DeviceApp
     */
    'create_by'?: string;
    /**
     * Set the marketplace package ID.
     * @type {string}
     * @memberof DeviceApp
     */
    'package_id'?: string;
    /**
     * Set the marketplace product ID.
     * @type {string}
     * @memberof DeviceApp
     */
    'product_id'?: string;
    /**
     * 
     * @type {SchemaInfo}
     * @memberof DeviceApp
     */
    'schema_info'?: SchemaInfo;
    /**
     * 
     * @type {Array<DeviceAppVersionsInner>}
     * @memberof DeviceApp
     */
    'versions'?: Array<DeviceAppVersionsInner>;
}
/**
 * 
 * @export
 * @interface DeviceAppDeployHistory
 */
export interface DeviceAppDeployHistory {
    /**
     * Set the deploy id.
     * @type {number}
     * @memberof DeviceAppDeployHistory
     */
    'id'?: number;
    /**
     * Set the total status. - Value definition   0: Running   1: Successfully completed   2: Failed   3: Canceled 
     * @type {string}
     * @memberof DeviceAppDeployHistory
     */
    'total_status'?: string;
    /**
     * Set the deploy parameter.
     * @type {string}
     * @memberof DeviceAppDeployHistory
     */
    'deploy_parameter'?: string;
    /**
     * 
     * @type {Array<DeviceAppDeployHistoryDevicesInner>}
     * @memberof DeviceAppDeployHistory
     */
    'devices'?: Array<DeviceAppDeployHistoryDevicesInner>;
}
/**
 * 
 * @export
 * @interface DeviceAppDeployHistoryDevicesInner
 */
export interface DeviceAppDeployHistoryDevicesInner {
    /**
     * Set the device id.
     * @type {string}
     * @memberof DeviceAppDeployHistoryDevicesInner
     */
    'device_id'?: string;
    /**
     * Set the total status. - Value definition   0: Running   1: Successfully completed   2: Failed   3: Canceled 
     * @type {string}
     * @memberof DeviceAppDeployHistoryDevicesInner
     */
    'status'?: string;
    /**
     * Set the deployment flg. - Value definition   0: Old deployment history   1: Recent deployment history 
     * @type {string}
     * @memberof DeviceAppDeployHistoryDevicesInner
     */
    'latest_deployment_flg'?: string;
    /**
     * Set the settings author.
     * @type {string}
     * @memberof DeviceAppDeployHistoryDevicesInner
     */
    'ins_id'?: string;
    /**
     * Set the date the settings were created.
     * @type {string}
     * @memberof DeviceAppDeployHistoryDevicesInner
     */
    'ins_date'?: string;
    /**
     * Set the settings updater.
     * @type {string}
     * @memberof DeviceAppDeployHistoryDevicesInner
     */
    'upd_id'?: string;
    /**
     * Set the date the settings were updated.
     * @type {string}
     * @memberof DeviceAppDeployHistoryDevicesInner
     */
    'upd_date'?: string;
}
/**
 * 
 * @export
 * @interface DeviceAppVersionsInner
 */
export interface DeviceAppVersionsInner {
    /**
     * Set the app version number.
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'version'?: string;
    /**
     * Set the compiled flg. - Value definition   0 : Specified App is not compiled   1 : Specified App is compiled 
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'compiled_flg'?: string;
    /**
     * Set the status. - Value definition   0: before compilation   1: during compilation   2: successful   3: failed 
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'status'?: string;
    /**
     * Set the comment.
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'comment'?: string;
    /**
     * Set the deploy count.
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'deploy_count'?: string;
    /**
     * Set the settings author.
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'ins_id'?: string;
    /**
     * Set the date the settings were created.
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'ins_date'?: string;
    /**
     * Set the settings updater.
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'upd_id'?: string;
    /**
     * Set the date the settings were updated.
     * @type {string}
     * @memberof DeviceAppVersionsInner
     */
    'upd_date'?: string;
}
/**
 * 
 * @export
 * @interface DeviceAppsInner
 */
export interface DeviceAppsInner {
    /**
     * Set the device app name.
     * @type {string}
     * @memberof DeviceAppsInner
     */
    'name'?: string;
    /**
     * Set the app version.
     * @type {string}
     * @memberof DeviceAppsInner
     */
    'version'?: string;
    /**
     * Set the app comment.
     * @type {string}
     * @memberof DeviceAppsInner
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface DeviceCertificate
 */
export interface DeviceCertificate {
    /**
     * Set the device ID.
     * @type {string}
     * @memberof DeviceCertificate
     */
    'device_id'?: string;
    /**
     * Set the internal device id.
     * @type {string}
     * @memberof DeviceCertificate
     */
    'internal_device_id'?: string;
    /**
     * Set the device name.
     * @type {string}
     * @memberof DeviceCertificate
     */
    'device_name'?: string;
    /**
     * Set the credentials id object.
     * @type {string}
     * @memberof DeviceCertificate
     */
    'credentials_id_object'?: string;
    /**
     * Set the credentials type.
     * @type {string}
     * @memberof DeviceCertificate
     */
    'credentials_type'?: string;
    /**
     * Set the expiration date.
     * @type {string}
     * @memberof DeviceCertificate
     */
    'expiration_date'?: string;
    /**
     * Set the created time.
     * @type {string}
     * @memberof DeviceCertificate
     */
    'created_time'?: string;
}
/**
 * 
 * @export
 * @interface DeviceCommandResultsInner
 */
export interface DeviceCommandResultsInner {
    /**
     * Set the device command name.
     * @type {string}
     * @memberof DeviceCommandResultsInner
     */
    'command_name'?: string;
    /**
     * Set the commnad result.
     * @type {string}
     * @memberof DeviceCommandResultsInner
     */
    'result'?: string;
    /**
     * Set the command execute time.
     * @type {string}
     * @memberof DeviceCommandResultsInner
     */
    'execute_time'?: string;
}
/**
 * 
 * @export
 * @interface DeviceDeviceGroupsInner
 */
export interface DeviceDeviceGroupsInner {
    /**
     * Set the device group ID.
     * @type {string}
     * @memberof DeviceDeviceGroupsInner
     */
    'device_group_id': string;
    /**
     * Set the device type.
     * @type {string}
     * @memberof DeviceDeviceGroupsInner
     */
    'device_type': string;
    /**
     * Set the device group comment.
     * @type {string}
     * @memberof DeviceDeviceGroupsInner
     */
    'comment'?: string;
    /**
     * Set the date the device group was created.
     * @type {string}
     * @memberof DeviceDeviceGroupsInner
     */
    'ins_id': string;
    /**
     * Set the device group author.
     * @type {string}
     * @memberof DeviceDeviceGroupsInner
     */
    'ins_date': string;
    /**
     * Set the device group updater.
     * @type {string}
     * @memberof DeviceDeviceGroupsInner
     */
    'upd_id': string;
    /**
     * Set the date the device group was updated.
     * @type {string}
     * @memberof DeviceDeviceGroupsInner
     */
    'upd_date': string;
}
/**
 * 
 * @export
 * @interface DeviceGroup
 */
export interface DeviceGroup {
    /**
     * Set the device group ID.
     * @type {string}
     * @memberof DeviceGroup
     */
    'device_group_id'?: string;
    /**
     * Set the device type.
     * @type {string}
     * @memberof DeviceGroup
     */
    'device_type'?: string;
    /**
     * Set the device group comment.
     * @type {string}
     * @memberof DeviceGroup
     */
    'comment'?: string;
    /**
     * Set the device group author.
     * @type {string}
     * @memberof DeviceGroup
     */
    'ins_id'?: string;
    /**
     * Set the date the device group was created.
     * @type {string}
     * @memberof DeviceGroup
     */
    'ins_date'?: string;
    /**
     * Set the device group updater.
     * @type {string}
     * @memberof DeviceGroup
     */
    'upd_id'?: string;
    /**
     * Set the date the device group was updated.
     * @type {string}
     * @memberof DeviceGroup
     */
    'upd_date'?: string;
    /**
     * 
     * @type {Array<DeviceGroupDevicesInner>}
     * @memberof DeviceGroup
     */
    'devices'?: Array<DeviceGroupDevicesInner>;
}
/**
 * 
 * @export
 * @interface DeviceGroupDevicesInner
 */
export interface DeviceGroupDevicesInner {
    /**
     * Set the device ID.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'device_id'?: string;
    /**
     * 
     * @type {DeviceProperty}
     * @memberof DeviceGroupDevicesInner
     */
    'property'?: DeviceProperty;
    /**
     * Set the device type.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'device_type'?: string;
    /**
     * Set the display device type.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'display_device_type'?: string;
    /**
     * Set the location.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'place'?: string;
    /**
     * Set the device comment.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'comment'?: string;
    /**
     * Set the device author.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'ins_id'?: string;
    /**
     * Set the date the device was created.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'ins_date'?: string;
    /**
     * Set the device updater.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'upd_id'?: string;
    /**
     * Set the date the device was updated.
     * @type {string}
     * @memberof DeviceGroupDevicesInner
     */
    'upd_date'?: string;
}
/**
 * 
 * @export
 * @interface DeviceModelsInner
 */
export interface DeviceModelsInner {
    /**
     * Set the model version ID. Format: modelid:v1.01 *For model that does not exist in the system, display network_id   Example: 000237
     * @type {string}
     * @memberof DeviceModelsInner
     */
    'model_version_id'?: string;
}
/**
 * 
 * @export
 * @interface DeviceProperty
 */
export interface DeviceProperty {
    /**
     * Set the device name.
     * @type {string}
     * @memberof DeviceProperty
     */
    'device_name': string;
    /**
     * Set the internal device id.
     * @type {string}
     * @memberof DeviceProperty
     */
    'internal_device_id': string;
}
/**
 * 
 * @export
 * @interface Devices
 */
export interface Devices {
    /**
     * Set the device ID.
     * @type {string}
     * @memberof Devices
     */
    'device_id': string;
    /**
     * Set the location.
     * @type {string}
     * @memberof Devices
     */
    'place'?: string;
    /**
     * Set the device description.
     * @type {string}
     * @memberof Devices
     */
    'comment'?: string;
    /**
     * 
     * @type {DeviceProperty}
     * @memberof Devices
     */
    'property'?: DeviceProperty;
    /**
     * Set the device type.
     * @type {string}
     * @memberof Devices
     */
    'device_type'?: string;
    /**
     * Set the display device type.
     * @type {string}
     * @memberof Devices
     */
    'display_device_type'?: string;
    /**
     * Set the device author.
     * @type {string}
     * @memberof Devices
     */
    'ins_id': string;
    /**
     * Set the date the device was created.
     * @type {string}
     * @memberof Devices
     */
    'ins_date': string;
    /**
     * Set the device updater.
     * @type {string}
     * @memberof Devices
     */
    'upd_id': string;
    /**
     * Set the date the device was updated.
     * @type {string}
     * @memberof Devices
     */
    'upd_date': string;
    /**
     * Set the device connection state.
     * @type {string}
     * @memberof Devices
     */
    'connectionState': string;
    /**
     * Set the date the device last connected.
     * @type {string}
     * @memberof Devices
     */
    'lastActivityTime': string;
    /**
     * 
     * @type {Array<DeviceModelsInner>}
     * @memberof Devices
     */
    'models'?: Array<DeviceModelsInner>;
    /**
     * 
     * @type {object}
     * @memberof Devices
     */
    'configuration'?: object;
    /**
     * 
     * @type {object}
     * @memberof Devices
     */
    'state'?: object;
    /**
     * 
     * @type {Array<DeviceDeviceGroupsInner>}
     * @memberof Devices
     */
    'device_groups'?: Array<DeviceDeviceGroupsInner>;
}
/**
 * EnrollDevice Json Body
 * @export
 * @interface EnrollDeviceJsonBody
 */
export interface EnrollDeviceJsonBody {
    /**
     * Device name. *Max. 255 characters
     * @type {string}
     * @memberof EnrollDeviceJsonBody
     */
    'device_name': string;
    /**
     * Device type include \"t3p\", \"t3w\".
     * @type {string}
     * @memberof EnrollDeviceJsonBody
     */
    'device_type'?: string;
    /**
     * X.509 primary certificate (.pem file or .cer file or .crt file) . *Specify the following certificate without the leading and trailing signatures. -----BEGIN CERTIFICATE-----  -----END CERTIFICATE-----  Also, do not include line breaks.
     * @type {string}
     * @memberof EnrollDeviceJsonBody
     */
    'primary_certificate': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Set \"ERROR\" fixing.
     * @type {string}
     * @memberof ErrorResponse
     */
    'result': string;
    /**
     * Set the error code.
     * @type {string}
     * @memberof ErrorResponse
     */
    'code': string;
    /**
     * Set the error message details or the reason.
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * Set the time the error occurred.* yyyy-MM-dd\'T\'HH:mm:ssXXX.
     * @type {string}
     * @memberof ErrorResponse
     */
    'time': string;
}
/**
 * 
 * @export
 * @interface EventLog
 */
export interface EventLog {
    /**
     * Set the event ID.
     * @type {string}
     * @memberof EventLog
     */
    'id'?: string;
    /**
     * Set the device ID.
     * @type {string}
     * @memberof EventLog
     */
    'DeviceID'?: string;
    /**
     * Set the log level.   Example: Warn, Error
     * @type {string}
     * @memberof EventLog
     */
    'Level'?: string;
    /**
     * Set the event component code.
     * @type {string}
     * @memberof EventLog
     */
    'Component'?: string;
    /**
     * Set the error code.
     * @type {string}
     * @memberof EventLog
     */
    'ErrorCode'?: string;
    /**
     * Set the description.
     * @type {string}
     * @memberof EventLog
     */
    'Description'?: string;
    /**
     * Set the event time.
     * @type {string}
     * @memberof EventLog
     */
    'Time'?: string;
    /**
     * Set the event log time ingested in system.
     * @type {string}
     * @memberof EventLog
     */
    'ingestion_time'?: string;
}
/**
 * 
 * @export
 * @interface ExportImages200Response
 */
export interface ExportImages200Response {
    /**
     * Shared key for decrypting images encrypted by a public key.
     * @type {string}
     * @memberof ExportImages200Response
     */
    'key'?: string;
    /**
     * SUS URI for downloading
     * @type {string}
     * @memberof ExportImages200Response
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface FWOperation
 */
export interface FWOperation {
    /**
     * 
     * @type {string}
     * @memberof FWOperation
     */
    'OperatingMode'?: FWOperationOperatingModeEnum;
    /**
     * 
     * @type {string}
     * @memberof FWOperation
     */
    'ErrorHandling': FWOperationErrorHandlingEnum;
    /**
     * 
     * @type {FWOperationPeriodicParameter}
     * @memberof FWOperation
     */
    'PeriodicParameter'?: FWOperationPeriodicParameter;
}

export const FWOperationOperatingModeEnum = {
    Manual: 'Manual',
    Periodic: 'Periodic'
} as const;

export type FWOperationOperatingModeEnum = typeof FWOperationOperatingModeEnum[keyof typeof FWOperationOperatingModeEnum];
export const FWOperationErrorHandlingEnum = {
    ManualReset: 'ManualReset',
    AutoReboot: 'AutoReboot'
} as const;

export type FWOperationErrorHandlingEnum = typeof FWOperationErrorHandlingEnum[keyof typeof FWOperationErrorHandlingEnum];

/**
 * 
 * @export
 * @interface FWOperationPeriodicParameter
 */
export interface FWOperationPeriodicParameter {
    /**
     * 
     * @type {string}
     * @memberof FWOperationPeriodicParameter
     */
    'NetworkParameter'?: FWOperationPeriodicParameterNetworkParameterEnum;
    /**
     * 
     * @type {PrimaryInterval}
     * @memberof FWOperationPeriodicParameter
     */
    'PrimaryInterval': PrimaryInterval;
    /**
     * 
     * @type {SecondaryInterval}
     * @memberof FWOperationPeriodicParameter
     */
    'SecondaryInterval': SecondaryInterval;
    /**
     * 
     * @type {UploadInferenceParameter}
     * @memberof FWOperationPeriodicParameter
     */
    'UploadInferenceParameter': UploadInferenceParameter;
}

export const FWOperationPeriodicParameterNetworkParameterEnum = {
    Save: 'Save',
    Dhcp: 'DHCP'
} as const;

export type FWOperationPeriodicParameterNetworkParameterEnum = typeof FWOperationPeriodicParameterNetworkParameterEnum[keyof typeof FWOperationPeriodicParameterNetworkParameterEnum];

/**
 * 
 * @export
 * @interface FileId
 */
export interface FileId {
    /**
     * file ID of the model file.
     * @type {string}
     * @memberof FileId
     */
    'model_file_id': string;
    /**
     * file ID of the input format param file.
     * @type {string}
     * @memberof FileId
     */
    'input_format_param_file_id'?: string;
    /**
     * file ID of the network config file.
     * @type {string}
     * @memberof FileId
     */
    'network_config_file_id'?: string;
}
/**
 * 
 * @export
 * @interface Firmware
 */
export interface Firmware {
    /**
     * Set the firmware ID.
     * @type {string}
     * @memberof Firmware
     */
    'firmware_id'?: string;
    /**
     * Set the firmware type.
     * @type {string}
     * @memberof Firmware
     */
    'firmware_type'?: string;
    /**
     * Set the firmware description.
     * @type {string}
     * @memberof Firmware
     */
    'comment'?: string;
    /**
     * Set the firmware author.
     * @type {string}
     * @memberof Firmware
     */
    'ins_id'?: string;
    /**
     * Set the date the firmware was created.
     * @type {string}
     * @memberof Firmware
     */
    'ins_date'?: string;
    /**
     * Set the firmware updater.
     * @type {string}
     * @memberof Firmware
     */
    'upd_id'?: string;
    /**
     * Set the date the firmware was updated.
     * @type {string}
     * @memberof Firmware
     */
    'upd_date'?: string;
    /**
     * 
     * @type {Array<FirmwareVersionsInner>}
     * @memberof Firmware
     */
    'versions'?: Array<FirmwareVersionsInner>;
}
/**
 * 
 * @export
 * @interface FirmwareVersionsInner
 */
export interface FirmwareVersionsInner {
    /**
     * Set the firmware filename.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'file_name'?: string;
    /**
     * Set the version number.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'version_number'?: string;
    /**
     * Set the ppl information.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'ppl'?: string;
    /**
     * Set the storage location type.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'stored_type'?: string;
    /**
     * Set the storage location URI.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'stored_uri'?: string;
    /**
     * Set the firmware description.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'comment'?: string;
    /**
     * Set the firmware author.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'ins_id'?: string;
    /**
     * Set the date the firmware was created.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'ins_date'?: string;
    /**
     * Set the firmware updater.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'upd_id'?: string;
    /**
     * Set the date the firmware was updated.
     * @type {string}
     * @memberof FirmwareVersionsInner
     */
    'upd_date'?: string;
}
/**
 * 
 * @export
 * @interface GetCommandParameterFile200Response
 */
export interface GetCommandParameterFile200Response {
    /**
     * 
     * @type {Array<GetCommandParameterFile200ResponseParameterListInner>}
     * @memberof GetCommandParameterFile200Response
     */
    'parameter_list': Array<GetCommandParameterFile200ResponseParameterListInner>;
}
/**
 * 
 * @export
 * @interface GetCommandParameterFile200ResponseParameterListInner
 */
export interface GetCommandParameterFile200ResponseParameterListInner {
    /**
     * 
     * @type {GetCommandParameterFile200ResponseParameterListInnerParameter}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'parameter': GetCommandParameterFile200ResponseParameterListInnerParameter;
    /**
     * Name of file
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'file_name': string;
    /**
     * Comment
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'comment'?: string;
    /**
     * True: Default parameter; False: Not default
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'isdefault': string;
    /**
     * Target device list.
     * @type {Array<string>}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'device_ids'?: Array<string>;
    /**
     * Set the settings author.
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'ins_id': string;
    /**
     * Set the date the settings were created.
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'ins_date': string;
    /**
     * Set the settings updater.
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'upd_id': string;
    /**
     * Set the date the settings were updated.
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInner
     */
    'upd_date': string;
}
/**
 * Setting value. json
 * @export
 * @interface GetCommandParameterFile200ResponseParameterListInnerParameter
 */
export interface GetCommandParameterFile200ResponseParameterListInnerParameter {
    /**
     * 
     * @type {Array<GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInner>}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameter
     */
    'commands': Array<GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInner>;
}
/**
 * 
 * @export
 * @interface GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInner
 */
export interface GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInner {
    /**
     * Command name.
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInner
     */
    'command_name': string;
    /**
     * 
     * @type {GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInner
     */
    'parameters': GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters;
}
/**
 * 
 * @export
 * @interface GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
 */
export interface GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters {
    /**
     * Collection mode. - Value definition   0 : Input Image only   1 : Input Image & Inference Result   2 : Inference Result only
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'Mode'?: number;
    /**
     * It specifies how to upload Input Image. - Value definition   BlobStorage
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'UploadMethod'?: string;
    /**
     * Image file format. - Value definition   JPG   BMP
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'FileFormat'?: string;
    /**
     * It specifies how to Inference Result. - Value definition   Mqtt
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'UploadMethodIR'?: string;
    /**
     * Hoffset for Image crop. - Value range : 0 to 4055
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'CropHOffset'?: number;
    /**
     * Hoffset for Image crop. - Value range : 0 to 3039
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'CropVOffset'?: number;
    /**
     * Hoffset for Image crop. - Value range : 0 to 4056
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'CropHSize'?: number;
    /**
     * Hoffset for Image crop. - Value range : 0 to 3040
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'CropVSize'?: number;
    /**
     * Number of images to fetch(Input Image). When it is 0, continue fetching images until stop instruction is mentioned explicitly. - Value range : 0 to 10000
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'NumberOfImages'?: number;
    /**
     * Upload interval. - Value range : 1 to 2592000 *If 60 is specified, 0.5FPS (=30/60)
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'UploadInterval'?: number;
    /**
     * Number of inference results to include in one message (Inference Result). - Value range : 1  to 100
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'NumberOfInferencesPerMessage'?: number;
    /**
     * No. of Objects included in 1 frame with respect to the Inference results metadata. - Value range : 1 to 5
     * @type {number}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'MaxDetectionsPerFrame'?: number;
    /**
     * Model ID.
     * @type {string}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'ModelId'?: string;
    /**
     * PPL parameter
     * @type {object}
     * @memberof GetCommandParameterFile200ResponseParameterListInnerParameterCommandsInnerParameters
     */
    'PPLParameter'?: object;
}
/**
 * 
 * @export
 * @interface GetDeployConfigurations200Response
 */
export interface GetDeployConfigurations200Response {
    /**
     * 
     * @type {Array<DeployConfiguration>}
     * @memberof GetDeployConfigurations200Response
     */
    'deploy_configurations': Array<DeployConfiguration>;
}
/**
 * 
 * @export
 * @interface GetDeployHistory200Response
 */
export interface GetDeployHistory200Response {
    /**
     * 
     * @type {Array<DeployHistory>}
     * @memberof GetDeployHistory200Response
     */
    'deploys': Array<DeployHistory>;
}
/**
 * 
 * @export
 * @interface GetDeviceAppDeploys200Response
 */
export interface GetDeviceAppDeploys200Response {
    /**
     * 
     * @type {Array<DeviceAppDeployHistory>}
     * @memberof GetDeviceAppDeploys200Response
     */
    'deploys': Array<DeviceAppDeployHistory>;
}
/**
 * 
 * @export
 * @interface GetDeviceApps200Response
 */
export interface GetDeviceApps200Response {
    /**
     * 
     * @type {Array<DeviceApp>}
     * @memberof GetDeviceApps200Response
     */
    'apps': Array<DeviceApp>;
}
/**
 * 
 * @export
 * @interface GetDevices200Response
 */
export interface GetDevices200Response {
    /**
     * 
     * @type {Array<Devices>}
     * @memberof GetDevices200Response
     */
    'devices': Array<Devices>;
}
/**
 * 
 * @export
 * @interface GetImageDirectories200ResponseInner
 */
export interface GetImageDirectories200ResponseInner {
    /**
     * Set the device group ID.
     * @type {string}
     * @memberof GetImageDirectories200ResponseInner
     */
    'group_id': string;
    /**
     * 
     * @type {Array<GetImageDirectories200ResponseInnerDevicesInner>}
     * @memberof GetImageDirectories200ResponseInner
     */
    'devices': Array<GetImageDirectories200ResponseInnerDevicesInner>;
}
/**
 * 
 * @export
 * @interface GetImageDirectories200ResponseInnerDevicesInner
 */
export interface GetImageDirectories200ResponseInnerDevicesInner {
    /**
     * Set the device ID.
     * @type {string}
     * @memberof GetImageDirectories200ResponseInnerDevicesInner
     */
    'device_id': string;
    /**
     * Set the device name.
     * @type {string}
     * @memberof GetImageDirectories200ResponseInnerDevicesInner
     */
    'device_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetImageDirectories200ResponseInnerDevicesInner
     */
    'Image': Array<string>;
}
/**
 * 
 * @export
 * @interface GetImages200Response
 */
export interface GetImages200Response {
    /**
     * Set the total number of images.
     * @type {number}
     * @memberof GetImages200Response
     */
    'total_image_count': number;
    /**
     * 
     * @type {Array<GetImages200ResponseImagesInner>}
     * @memberof GetImages200Response
     */
    'images': Array<GetImages200ResponseImagesInner>;
}
/**
 * 
 * @export
 * @interface GetImages200ResponseImagesInner
 */
export interface GetImages200ResponseImagesInner {
    /**
     * Set the image filename.
     * @type {string}
     * @memberof GetImages200ResponseImagesInner
     */
    'name': string;
    /**
     * Images file contents (BASE64 encoding).
     * @type {string}
     * @memberof GetImages200ResponseImagesInner
     */
    'contents': string;
}
/**
 * 
 * @export
 * @interface GetInferenceResults200ResponseInner
 */
export interface GetInferenceResults200ResponseInner {
    /**
     * Inference result metadata ID. =GUID generated automatically by CosmosDB
     * @type {string}
     * @memberof GetInferenceResults200ResponseInner
     */
    'id'?: string;
    /**
     * Device ID.
     * @type {string}
     * @memberof GetInferenceResults200ResponseInner
     */
    'device_id'?: string;
    /**
     * Model ID.
     * @type {string}
     * @memberof GetInferenceResults200ResponseInner
     */
    'model_id'?: string;
    /**
     * Version number.
     * @type {string}
     * @memberof GetInferenceResults200ResponseInner
     */
    'version_number'?: string;
    /**
     * Model version ID.
     * @type {string}
     * @memberof GetInferenceResults200ResponseInner
     */
    'model_version_id'?: string;
    /**
     * Model type. 00: Image category 01: Object detection
     * @type {string}
     * @memberof GetInferenceResults200ResponseInner
     */
    'model_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInferenceResults200ResponseInner
     */
    'training_kit_name'?: string;
    /**
     * Time stamp. =_ts of CosmosDB
     * @type {number}
     * @memberof GetInferenceResults200ResponseInner
     */
    '_ts'?: number;
    /**
     * 
     * @type {InferenceResult}
     * @memberof GetInferenceResults200ResponseInner
     */
    'inference_result'?: InferenceResult;
    /**
     * 
     * @type {Array<Inference>}
     * @memberof GetInferenceResults200ResponseInner
     */
    'inferences'?: Array<Inference>;
}
/**
 * 
 * @export
 * @interface GetModels200Response
 */
export interface GetModels200Response {
    /**
     * 
     * @type {Array<Model>}
     * @memberof GetModels200Response
     */
    'models'?: Array<Model>;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * Set the image ID.
     * @type {string}
     * @memberof Image
     */
    'id'?: string;
    /**
     * Set the creation date.
     * @type {string}
     * @memberof Image
     */
    'created'?: string;
    /**
     * Set the image width.
     * @type {number}
     * @memberof Image
     */
    'width'?: number;
    /**
     * Set the image height.
     * @type {number}
     * @memberof Image
     */
    'height'?: number;
    /**
     * Set the image file(BASE64 encoding).
     * @type {string}
     * @memberof Image
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ImageTagsInner>}
     * @memberof Image
     */
    'tags'?: Array<ImageTagsInner>;
    /**
     * 
     * @type {Array<Region>}
     * @memberof Image
     */
    'regions'?: Array<Region>;
}
/**
 * 
 * @export
 * @interface ImageTagsInner
 */
export interface ImageTagsInner {
    /**
     * Set the tag ID.
     * @type {string}
     * @memberof ImageTagsInner
     */
    'tag_id'?: string;
    /**
     * Set the tag name.
     * @type {string}
     * @memberof ImageTagsInner
     */
    'tag_name'?: string;
    /**
     * Set the creation date.
     * @type {string}
     * @memberof ImageTagsInner
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface ImagesInner
 */
export interface ImagesInner {
    /**
     * Set the filename.
     * @type {string}
     * @memberof ImagesInner
     */
    'file_name'?: string;
    /**
     * Set the image file(BASE64 encoding)
     * @type {string}
     * @memberof ImagesInner
     */
    'contents'?: string;
}
/**
 * 
 * @export
 * @interface ImportBaseModelJsonBody
 */
export interface ImportBaseModelJsonBody {
    /**
     * SAS URI or Presigned URI of the model file.
     * @type {string}
     * @memberof ImportBaseModelJsonBody
     */
    'model': string;
    /**
     * SAS URI or Presigned URI of the input format param file. *Usage: Packager conversion information (image format information). *The json format is an array of objects. Each object contains the following values. &nbsp; - ordinal: Order of DNN input to converter (value range: 0 to 2) &nbsp; - format: Format (\"RGB\" or \"BGR\") *Example: &nbsp;[{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"ordinal\": 0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"format\": \"RGB\" &nbsp;}, &nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"ordinal\": 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"format\": \"RGB\" &nbsp;}]
     * @type {string}
     * @memberof ImportBaseModelJsonBody
     */
    'input_format_param'?: string;
    /**
     * SAS URI or Presigned URI of the network config file. *Usage: Conversion parameter information of modelconverter. Therefore, it is not necessary to specify when specifying the model before conversion. *Example: &nbsp;{ &nbsp;&nbsp;&nbsp;\"Postprocessor\": { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"params\": { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"background\": false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"scale_factors\": [ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"score_thresh\": 0.01, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"max_size_per_class\": 64, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"max_total_size\": 64, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"clip_window\": [ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"iou_threshold\": 0.45 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;} &nbsp;}
     * @type {string}
     * @memberof ImportBaseModelJsonBody
     */
    'network_config'?: string;
    /**
     * Model ID for new registration or version upgrade. Max. 100 characters.
     * @type {string}
     * @memberof ImportBaseModelJsonBody
     */
    'model_id': string;
    /**
     * Specify whether to convert the specified model file.
     * @type {boolean}
     * @memberof ImportBaseModelJsonBody
     */
    'converted'?: boolean;
    /**
     * Vendor Name. Max. 100 characters. *Specify only when registering a new base model.
     * @type {string}
     * @memberof ImportBaseModelJsonBody
     */
    'vendor_name'?: string;
    /**
     * Description. Max. 100 characters. *When saving new, it is set as a description of the model and version. *When saving version-up, it is set as a description of the version.
     * @type {string}
     * @memberof ImportBaseModelJsonBody
     */
    'comment'?: string;
    /**
     * Specify whether or not application is required for the model. - Value definition   0 : Model required application   1 : Model do not required application
     * @type {string}
     * @memberof ImportBaseModelJsonBody
     */
    'network_type'?: string;
    /**
     * Metadata Format ID. Max. 100 characters.
     * @type {string}
     * @memberof ImportBaseModelJsonBody
     */
    'metadata_format_id'?: string;
}
/**
 * ImportDeviceApp Json Body
 * @export
 * @interface ImportDeviceAppJsonBody
 */
export interface ImportDeviceAppJsonBody {
    /**
     * Set the compiled flg. - Value definition   0 : Specified App is not compiled   1 : Specified App is compiled 
     * @type {string}
     * @memberof ImportDeviceAppJsonBody
     */
    'compiled_flg': string;
    /**
     * App entry point.
     * @type {string}
     * @memberof ImportDeviceAppJsonBody
     */
    'entry_point'?: string;
    /**
     * App name. *Allow only the following characters.  Alphanumeric characters  Under bar  Dot *The maximum number of characters is app_name + version_number <=31.
     * @type {string}
     * @memberof ImportDeviceAppJsonBody
     */
    'app_name': string;
    /**
     * App version number. *Allow only the following characters.  Alphanumeric characters  Under bar  Dot *The maximum number of characters is app_name + version_number <=31.
     * @type {string}
     * @memberof ImportDeviceAppJsonBody
     */
    'version_number': string;
    /**
     * Comment. *Max. 100 characters.
     * @type {string}
     * @memberof ImportDeviceAppJsonBody
     */
    'comment'?: string;
    /**
     * filename.
     * @type {string}
     * @memberof ImportDeviceAppJsonBody
     */
    'file_name': string;
    /**
     * App file content in base64 encoding.
     * @type {string}
     * @memberof ImportDeviceAppJsonBody
     */
    'file_content': string;
    /**
     * 
     * @type {SchemaInfo1}
     * @memberof ImportDeviceAppJsonBody
     */
    'schema_info'?: SchemaInfo1;
}
/**
 * ImportImagesFromFiles JsonBody.
 * @export
 * @interface ImportImagesFromFilesJsonBody
 */
export interface ImportImagesFromFilesJsonBody {
    /**
     * 
     * @type {Array<ImagesInner>}
     * @memberof ImportImagesFromFilesJsonBody
     */
    'images': Array<ImagesInner>;
    /**
     * Set the label *Specify for classification. Supports only 1 tag.
     * @type {Array<any>}
     * @memberof ImportImagesFromFilesJsonBody
     */
    'tags_name'?: Array<any>;
}
/**
 * ImportImagesFromScblob JsonBody.
 * @export
 * @interface ImportImagesFromScblobJsonBody
 */
export interface ImportImagesFromScblobJsonBody {
    /**
     * Set the SAS URI of Blob Storage Container. *Read and List permissions required
     * @type {string}
     * @memberof ImportImagesFromScblobJsonBody
     */
    'container_url': string;
    /**
     * Set the label *Specify for classification. Supports only 1 tag.
     * @type {Array<any>}
     * @memberof ImportImagesFromScblobJsonBody
     */
    'tags_name'?: Array<any>;
}
/**
 * 
 * @export
 * @interface Inference
 */
export interface Inference {
    /**
     * Time when retrieving data from the sensor.
     * @type {string}
     * @memberof Inference
     */
    'T'?: string;
    /**
     * Output tensor (Encoding format).
     * @type {string}
     * @memberof Inference
     */
    'O'?: string;
}
/**
 * 
 * @export
 * @interface InferenceResult
 */
export interface InferenceResult {
    /**
     * Device ID.
     * @type {string}
     * @memberof InferenceResult
     */
    'DeviceID'?: string;
    /**
     * DnnModelVersion.
     * @type {string}
     * @memberof InferenceResult
     */
    'ModelID'?: string;
    /**
     * Synchronized to the InputTensor output.
     * @type {boolean}
     * @memberof InferenceResult
     */
    'Image'?: boolean;
    /**
     * 
     * @type {Array<Inference>}
     * @memberof InferenceResult
     */
    'Inferences'?: Array<Inference>;
    /**
     * 
     * @type {string}
     * @memberof InferenceResult
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof InferenceResult
     */
    'ttl'?: number;
    /**
     * 
     * @type {string}
     * @memberof InferenceResult
     */
    '_rid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InferenceResult
     */
    '_self'?: string;
    /**
     * 
     * @type {string}
     * @memberof InferenceResult
     */
    '_etag'?: string;
    /**
     * 
     * @type {string}
     * @memberof InferenceResult
     */
    '_attachments'?: string;
    /**
     * 
     * @type {number}
     * @memberof InferenceResult
     */
    '_ts'?: number;
}
/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * Set the model ID.
     * @type {string}
     * @memberof Model
     */
    'model_id'?: string;
    /**
     * Set the model type.
     * @type {string}
     * @memberof Model
     */
    'model_type'?: string;
    /**
     * Set the function descriptions.
     * @type {string}
     * @memberof Model
     */
    'functionality'?: string;
    /**
     * Set the vendor name.
     * @type {string}
     * @memberof Model
     */
    'vendor_name'?: string;
    /**
     * Set the description.
     * @type {string}
     * @memberof Model
     */
    'model_comment'?: string;
    /**
     * Set the network type.
     * @type {string}
     * @memberof Model
     */
    'network_type'?: string;
    /**
     * Set the create_by. - Value definition   Self: Self-training models   Marketplace: Marketplace purchacing model 
     * @type {string}
     * @memberof Model
     */
    'create_by'?: string;
    /**
     * Set the marketplace package ID.
     * @type {string}
     * @memberof Model
     */
    'package_id'?: string;
    /**
     * Set the marketplace product ID.
     * @type {string}
     * @memberof Model
     */
    'product_id'?: string;
    /**
     * Set the metadata_format_id.
     * @type {string}
     * @memberof Model
     */
    'metadata_format_id'?: string;
    /**
     * 
     * @type {Array<ModelProjectOfModel>}
     * @memberof Model
     */
    'projects'?: Array<ModelProjectOfModel>;
}
/**
 * 
 * @export
 * @interface ModelInfo
 */
export interface ModelInfo {
    /**
     * Set the model ID.
     * @type {string}
     * @memberof ModelInfo
     */
    'model_id'?: string;
    /**
     * Set the model type.
     * @type {string}
     * @memberof ModelInfo
     */
    'model_type'?: string;
    /**
     * Set the function descriptions.
     * @type {string}
     * @memberof ModelInfo
     */
    'functionality'?: string;
    /**
     * Set the vendor name.
     * @type {string}
     * @memberof ModelInfo
     */
    'vendor_name'?: string;
    /**
     * Set the description.
     * @type {string}
     * @memberof ModelInfo
     */
    'model_comment'?: string;
    /**
     * Set the network type.
     * @type {string}
     * @memberof ModelInfo
     */
    'network_type'?: string;
    /**
     * Set the create_by. - Value definition   Self: Self-training models   Marketplace: Marketplace purchacing model 
     * @type {string}
     * @memberof ModelInfo
     */
    'create_by'?: string;
    /**
     * Set the marketplace package ID.
     * @type {string}
     * @memberof ModelInfo
     */
    'package_id'?: string;
    /**
     * Set the marketplace product ID.
     * @type {string}
     * @memberof ModelInfo
     */
    'product_id'?: string;
    /**
     * Set the metadata_format_id.
     * @type {string}
     * @memberof ModelInfo
     */
    'metadata_format_id'?: string;
    /**
     * 
     * @type {Array<ModelProjectOfModelInfo>}
     * @memberof ModelInfo
     */
    'projects'?: Array<ModelProjectOfModelInfo>;
}
/**
 * 
 * @export
 * @interface ModelProject
 */
export interface ModelProject {
    /**
     * Set the model project name.
     * @type {string}
     * @memberof ModelProject
     */
    'model_project_name': string;
    /**
     * Set the model project ID.
     * @type {string}
     * @memberof ModelProject
     */
    'model_project_id': string;
    /**
     * Set the model platform.
     * @type {string}
     * @memberof ModelProject
     */
    'model_platform'?: string;
    /**
     * Set the model type.
     * @type {string}
     * @memberof ModelProject
     */
    'model_type'?: string;
    /**
     * Set the project type.
     * @type {string}
     * @memberof ModelProject
     */
    'project_type'?: string;
    /**
     * Set the model device id.
     * @type {string}
     * @memberof ModelProject
     */
    'device_id'?: string;
    /**
     * Set the project model filename.
     * @type {string}
     * @memberof ModelProject
     */
    'project_model_file_name'?: string;
    /**
     * Set the project model accuracy.
     * @type {string}
     * @memberof ModelProject
     */
    'project_model_accuracy'?: string;
    /**
     * Set the project comment.
     * @type {string}
     * @memberof ModelProject
     */
    'project_comment'?: string;
    /**
     * 
     * @type {ModelProjectProject}
     * @memberof ModelProject
     */
    'project'?: ModelProjectProject;
    /**
     * 
     * @type {ModelProjectModel}
     * @memberof ModelProject
     */
    'model'?: ModelProjectModel;
}
/**
 * 
 * @export
 * @interface ModelProjectInfo
 */
export interface ModelProjectInfo {
    /**
     * Set the model project name.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'model_project_name': string;
    /**
     * Set the model project ID.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'model_project_id': string;
    /**
     * Set the model platform.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'model_platform'?: string;
    /**
     * Set the model type.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'model_type'?: string;
    /**
     * Set the project type.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'project_type'?: string;
    /**
     * Set the model device id.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'device_id'?: string;
    /**
     * Set the project model filename.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'project_model_file_name'?: string;
    /**
     * Set the project model accuracy.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'project_model_accuracy'?: string;
    /**
     * Set the project comment.
     * @type {string}
     * @memberof ModelProjectInfo
     */
    'project_comment'?: string;
    /**
     * 
     * @type {ModelProjectProject}
     * @memberof ModelProjectInfo
     */
    'project'?: ModelProjectProject;
    /**
     * 
     * @type {ModelProjectInfoModel}
     * @memberof ModelProjectInfo
     */
    'model'?: ModelProjectInfoModel;
}
/**
 * 
 * @export
 * @interface ModelProjectInfoModel
 */
export interface ModelProjectInfoModel {
    /**
     * Set the model ID.
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'model_id'?: string;
    /**
     * Set the device type.
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'model_type'?: string;
    /**
     * Set the function descriptions.
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'functionality'?: string;
    /**
     * Set the vendor name.
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'vendor_name'?: string;
    /**
     * Set the description.
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'model_comment'?: string;
    /**
     * Set the create_by. - Value definition   Self: Self-training models   Marketplace: Marketplace purchacing model 
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'create_by'?: string;
    /**
     * Set the marketplace package ID.
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'package_id'?: string;
    /**
     * Set the marketplace product ID.
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'product_id'?: string;
    /**
     * Set the metadata_format_id.
     * @type {string}
     * @memberof ModelProjectInfoModel
     */
    'metadata_format_id'?: string;
    /**
     * 
     * @type {ModelVersionJsonBody}
     * @memberof ModelProjectInfoModel
     */
    'latest_version'?: ModelVersionJsonBody;
}
/**
 * 
 * @export
 * @interface ModelProjectModel
 */
export interface ModelProjectModel {
    /**
     * Set the model ID.
     * @type {string}
     * @memberof ModelProjectModel
     */
    'model_id'?: string;
    /**
     * Set the device type.
     * @type {string}
     * @memberof ModelProjectModel
     */
    'model_type'?: string;
    /**
     * Set the function descriptions.
     * @type {string}
     * @memberof ModelProjectModel
     */
    'functionality'?: string;
    /**
     * Set the vendor name.
     * @type {string}
     * @memberof ModelProjectModel
     */
    'vendor_name'?: string;
    /**
     * Set the description.
     * @type {string}
     * @memberof ModelProjectModel
     */
    'model_comment'?: string;
    /**
     * Set the create_by. - Value definition   Self: Self-training models   Marketplace: Marketplace purchacing model 
     * @type {string}
     * @memberof ModelProjectModel
     */
    'create_by'?: string;
    /**
     * Set the marketplace package ID.
     * @type {string}
     * @memberof ModelProjectModel
     */
    'package_id'?: string;
    /**
     * Set the marketplace product ID.
     * @type {string}
     * @memberof ModelProjectModel
     */
    'product_id'?: string;
    /**
     * Set the metadata_format_id.
     * @type {string}
     * @memberof ModelProjectModel
     */
    'metadata_format_id'?: string;
    /**
     * 
     * @type {ModelVersion}
     * @memberof ModelProjectModel
     */
    'latest_version'?: ModelVersion;
}
/**
 * 
 * @export
 * @interface ModelProjectOfModel
 */
export interface ModelProjectOfModel {
    /**
     * Set the model project name.
     * @type {string}
     * @memberof ModelProjectOfModel
     */
    'model_project_name'?: string;
    /**
     * Set the model project ID.
     * @type {string}
     * @memberof ModelProjectOfModel
     */
    'model_project_id'?: string;
    /**
     * Set the model platform.
     * @type {string}
     * @memberof ModelProjectOfModel
     */
    'model_platform'?: string;
    /**
     * Set the model type.
     * @type {string}
     * @memberof ModelProjectOfModel
     */
    'model_type'?: string;
    /**
     * Set the project type.
     * @type {string}
     * @memberof ModelProjectOfModel
     */
    'project_type'?: string;
    /**
     * Set the device ID
     * @type {string}
     * @memberof ModelProjectOfModel
     */
    'device_id'?: string;
    /**
     * There must be one subordinate element for this API.
     * @type {Array<ModelVersion>}
     * @memberof ModelProjectOfModel
     */
    'versions'?: Array<ModelVersion>;
}
/**
 * 
 * @export
 * @interface ModelProjectOfModelInfo
 */
export interface ModelProjectOfModelInfo {
    /**
     * Set the model project name.
     * @type {string}
     * @memberof ModelProjectOfModelInfo
     */
    'model_project_name'?: string;
    /**
     * Set the model project ID.
     * @type {string}
     * @memberof ModelProjectOfModelInfo
     */
    'model_project_id'?: string;
    /**
     * Set the model platform.
     * @type {string}
     * @memberof ModelProjectOfModelInfo
     */
    'model_platform'?: string;
    /**
     * Set the model type.
     * @type {string}
     * @memberof ModelProjectOfModelInfo
     */
    'model_type'?: string;
    /**
     * Set the project type.
     * @type {string}
     * @memberof ModelProjectOfModelInfo
     */
    'project_type'?: string;
    /**
     * Set the device ID
     * @type {string}
     * @memberof ModelProjectOfModelInfo
     */
    'device_id'?: string;
    /**
     * There must be one subordinate element for this API.
     * @type {Array<ModelVersionInfo>}
     * @memberof ModelProjectOfModelInfo
     */
    'versions'?: Array<ModelVersionInfo>;
}
/**
 * 
 * @export
 * @interface ModelProjectProject
 */
export interface ModelProjectProject {
    /**
     * Set the training kit id.
     * @type {string}
     * @memberof ModelProjectProject
     */
    'training_kit_id'?: string;
    /**
     * Set the training kit name.
     * @type {string}
     * @memberof ModelProjectProject
     */
    'training_kit_name'?: string;
    /**
     * Set the description.
     * @type {string}
     * @memberof ModelProjectProject
     */
    'description'?: string;
    /**
     * Set the iteration id.
     * @type {string}
     * @memberof ModelProjectProject
     */
    'iteration_id'?: string;
    /**
     * Set the iteration name.
     * @type {string}
     * @memberof ModelProjectProject
     */
    'iteration_name'?: string;
    /**
     * Set the last modified.
     * @type {string}
     * @memberof ModelProjectProject
     */
    'last_modified'?: string;
}
/**
 * 
 * @export
 * @interface ModelVersion
 */
export interface ModelVersion {
    /**
     * Set the version number.
     * @type {string}
     * @memberof ModelVersion
     */
    'version_number'?: string;
    /**
     * Set the iteration ID.
     * @type {string}
     * @memberof ModelVersion
     */
    'iteration_id'?: string;
    /**
     * Set the iteration name.
     * @type {string}
     * @memberof ModelVersion
     */
    'iteration_name'?: string;
    /**
     * Set the accuracy.
     * @type {string}
     * @memberof ModelVersion
     */
    'accuracy'?: string;
    /**
     * Set the the performance information of the model.
     * @type {object}
     * @memberof ModelVersion
     */
    'model_performances'?: object;
    /**
     * Set the latest flag.
     * @type {string}
     * @memberof ModelVersion
     */
    'latest_flg'?: string;
    /**
     * Set the latest published flag.
     * @type {string}
     * @memberof ModelVersion
     */
    'publish_latest_flg'?: string;
    /**
     * Set the status.
     * @type {string}
     * @memberof ModelVersion
     */
    'version_status'?: string;
    /**
     * Set the preconversion model filename.
     * @type {string}
     * @memberof ModelVersion
     */
    'org_file_name'?: string;
    /**
     * Set the publish model file size.
     * @type {number}
     * @memberof ModelVersion
     */
    'org_file_size'?: number;
    /**
     * Set the publish model filename.
     * @type {string}
     * @memberof ModelVersion
     */
    'publish_file_name'?: string;
    /**
     * Set the publish model file size.
     * @type {number}
     * @memberof ModelVersion
     */
    'publish_file_size'?: number;
    /**
     * Set the model file size.
     * @type {number}
     * @memberof ModelVersion
     */
    'model_file_size'?: number;
    /**
     * Set the model framework.
     * @type {string}
     * @memberof ModelVersion
     */
    'model_framework'?: string;
    /**
     * Set the conversion request ID.
     * @type {string}
     * @memberof ModelVersion
     */
    'conv_id'?: string;
    /**
     * Set the label array.
     * @type {Array<string>}
     * @memberof ModelVersion
     */
    'labels'?: Array<string>;
    /**
     * Set the conversion stage.
     * @type {string}
     * @memberof ModelVersion
     */
    'stage'?: string;
    /**
     * Set the conversion result.
     * @type {string}
     * @memberof ModelVersion
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof ModelVersion
     */
    'kpi'?: object;
}
/**
 * 
 * @export
 * @interface ModelVersionInfo
 */
export interface ModelVersionInfo {
    /**
     * Set the version number.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'version_number'?: string;
    /**
     * Set the iteration ID.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'iteration_id'?: string;
    /**
     * Set the iteration name.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'iteration_name'?: string;
    /**
     * Set the accuracy.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'accuracy'?: string;
    /**
     * Set the the performance information of the model.
     * @type {object}
     * @memberof ModelVersionInfo
     */
    'model_performances'?: object;
    /**
     * Set the latest flag.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'latest_flg'?: string;
    /**
     * Set the latest published flag.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'publish_latest_flg'?: string;
    /**
     * Set the status.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'version_status'?: string;
    /**
     * Set the preconversion model filename.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'org_file_name'?: string;
    /**
     * Set the publish model file size.
     * @type {number}
     * @memberof ModelVersionInfo
     */
    'org_file_size'?: number;
    /**
     * Set the publish model filename.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'publish_file_name'?: string;
    /**
     * Set the publish model file size.
     * @type {number}
     * @memberof ModelVersionInfo
     */
    'publish_file_size'?: number;
    /**
     * Set the model file size.
     * @type {number}
     * @memberof ModelVersionInfo
     */
    'model_file_size'?: number;
    /**
     * Set the model framework.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'model_framework'?: string;
    /**
     * Set the conversion request ID.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'conv_id'?: string;
    /**
     * Set the label array.
     * @type {Array<string>}
     * @memberof ModelVersionInfo
     */
    'labels'?: Array<string>;
    /**
     * Set the conversion stage.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'stage'?: string;
    /**
     * Set the conversion result.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof ModelVersionInfo
     */
    'kpi'?: object;
    /**
     * converter log.
     * @type {Array<object>}
     * @memberof ModelVersionInfo
     */
    'converter_log'?: Array<object>;
    /**
     * Set the conversion start date.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'convert_start_date'?: string;
    /**
     * Set the conversion end date.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'convert_end_date'?: string;
    /**
     * Set the publish start date.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'publish_start_date'?: string;
    /**
     * Set the publish end date.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'publish_end_date'?: string;
    /**
     * Set the description.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'version_comment'?: string;
    /**
     * Set the the created time of the version.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'version_ins_date'?: string;
    /**
     * Set the the created time of the version.
     * @type {string}
     * @memberof ModelVersionInfo
     */
    'version_upd_date'?: string;
}
/**
 * 
 * @export
 * @interface ModelVersionJsonBody
 */
export interface ModelVersionJsonBody {
    /**
     * Set the version number.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'version_number'?: string;
    /**
     * Set the iteration ID.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'iteration_id'?: string;
    /**
     * Set the iteration name.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'iteration_name'?: string;
    /**
     * Set the accuracy.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'accuracy'?: string;
    /**
     * Set the the performance information of the model.
     * @type {object}
     * @memberof ModelVersionJsonBody
     */
    'model_performances'?: object;
    /**
     * Set the latest flag.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'latest_flg'?: string;
    /**
     * Set the latest published flag.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'publish_latest_flg'?: string;
    /**
     * Set the status.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'version_status'?: string;
    /**
     * Set the preconversion model filename.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'org_file_name'?: string;
    /**
     * Set the publish model file size.
     * @type {number}
     * @memberof ModelVersionJsonBody
     */
    'org_file_size'?: number;
    /**
     * Set the publish model filename.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'publish_file_name'?: string;
    /**
     * Set the publish model file size.
     * @type {number}
     * @memberof ModelVersionJsonBody
     */
    'publish_file_size'?: number;
    /**
     * Set the model file size.
     * @type {number}
     * @memberof ModelVersionJsonBody
     */
    'model_file_size'?: number;
    /**
     * Set the model framework.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'model_framework'?: string;
    /**
     * Set the conversion request ID.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'conv_id'?: string;
    /**
     * Set the label array.
     * @type {Array<string>}
     * @memberof ModelVersionJsonBody
     */
    'labels'?: Array<string>;
    /**
     * Set the conversion stage.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'stage'?: string;
    /**
     * Set the conversion result.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof ModelVersionJsonBody
     */
    'kpi'?: object;
    /**
     * converter log.
     * @type {Array<object>}
     * @memberof ModelVersionJsonBody
     */
    'converter_log'?: Array<object>;
    /**
     * Set the conversion start date.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'convert_start_date'?: string;
    /**
     * Set the conversion end date.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'convert_end_date'?: string;
    /**
     * Set the publish start date.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'publish_start_date'?: string;
    /**
     * Set the publish end date.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'publish_end_date'?: string;
    /**
     * Set the description.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'version_comment'?: string;
    /**
     * Set the the created time of the version.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'version_ins_date'?: string;
    /**
     * Set the the created time of the version.
     * @type {string}
     * @memberof ModelVersionJsonBody
     */
    'version_upd_date'?: string;
}
/**
 * 
 * @export
 * @interface PrimaryInterval
 */
export interface PrimaryInterval {
    /**
     * Interval at which to check for Config updates.Set in minutes.  0 : no Config. - Value definition   5 ~ 1440 :(24 hours)
     * @type {number}
     * @memberof PrimaryInterval
     */
    'ConfigInterval'?: number;
    /**
     * shooting interval. Set in minutes.  0 : no shooting. - Value definition   3 - 1440 :(24 hours)
     * @type {number}
     * @memberof PrimaryInterval
     */
    'CaptureInterval'?: number;
    /**
     * Reference time. (Hour: Minute) (Second is fixed at 00) - Value definition   \"00:00\" - \"23:59\"
     * @type {string}
     * @memberof PrimaryInterval
     */
    'BaseTime': string;
    /**
     * Primary is fixed at 1 - Value definition   1
     * @type {number}
     * @memberof PrimaryInterval
     */
    'UploadCount'?: number;
}
/**
 * 
 * @export
 * @interface PublishModel200Response
 */
export interface PublishModel200Response {
    /**
     * Set \"SUCCESS\" fixing
     * @type {string}
     * @memberof PublishModel200Response
     */
    'result'?: string;
    /**
     * Set the conv ID.
     * @type {string}
     * @memberof PublishModel200Response
     */
    'import_id'?: string;
}
/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * Set the region ID.
     * @type {string}
     * @memberof Region
     */
    'region_id'?: string;
    /**
     * Set the tag ID.
     * @type {string}
     * @memberof Region
     */
    'tag_id'?: string;
    /**
     * Set the tag name.
     * @type {string}
     * @memberof Region
     */
    'tag_name'?: string;
    /**
     * Set the creation date.
     * @type {string}
     * @memberof Region
     */
    'created'?: string;
    /**
     * left of region(ratio of image size). *Set only for object detection
     * @type {number}
     * @memberof Region
     */
    'left'?: number;
    /**
     * top of region(ratio of image size). *Set only for object detection
     * @type {number}
     * @memberof Region
     */
    'top'?: number;
    /**
     * width of region(ratio of image size). *Set only for object detection
     * @type {number}
     * @memberof Region
     */
    'width'?: number;
    /**
     * height of region(ratio of image size). *Set only for object detection
     * @type {number}
     * @memberof Region
     */
    'height'?: number;
}
/**
 * 
 * @export
 * @interface RegionsInner
 */
export interface RegionsInner {
    /**
     * Image id.
     * @type {string}
     * @memberof RegionsInner
     */
    'image_id': string;
    /**
     * Tag Id. *Specify when assigning an existing tag.
     * @type {string}
     * @memberof RegionsInner
     */
    'tag_id'?: string;
    /**
     * Tag Name. *Specify when assigning a new tag
     * @type {string}
     * @memberof RegionsInner
     */
    'tag_name'?: string;
    /**
     * left of region(ratio of image size). *Set only for object detection
     * @type {string}
     * @memberof RegionsInner
     */
    'left'?: string;
    /**
     * top of region(ratio of image size). *Set only for object detection
     * @type {string}
     * @memberof RegionsInner
     */
    'top'?: string;
    /**
     * width of region(ratio of image size). *Set only for object detection
     * @type {string}
     * @memberof RegionsInner
     */
    'width'?: string;
    /**
     * height of region(ratio of image size). *Set only for object detection
     * @type {string}
     * @memberof RegionsInner
     */
    'height'?: string;
}
/**
 * RegistCommandParameterFile Json Body
 * @export
 * @interface RegistCommandParameterFileBody
 */
export interface RegistCommandParameterFileBody {
    /**
     * Filename. Max. 100 characters.
     * @type {string}
     * @memberof RegistCommandParameterFileBody
     */
    'file_name': string;
    /**
     * Command parameter content in base64 encoding. *See manual for detailed format
     * @type {string}
     * @memberof RegistCommandParameterFileBody
     */
    'parameter': string;
    /**
     * Comment details.
     * @type {string}
     * @memberof RegistCommandParameterFileBody
     */
    'comment'?: string;
}
/**
 * Schema info.
 * @export
 * @interface SchemaInfo
 */
export interface SchemaInfo {
    /**
     * Set the VnS app ID.
     * @type {string}
     * @memberof SchemaInfo
     */
    'VnSAppId'?: string;
    /**
     * Set the app version no.
     * @type {string}
     * @memberof SchemaInfo
     */
    'version'?: string;
    /**
     * 
     * @type {SchemaInfoInterfaces}
     * @memberof SchemaInfo
     */
    'interfaces'?: SchemaInfoInterfaces;
}
/**
 * Schema info.
 * @export
 * @interface SchemaInfo1
 */
export interface SchemaInfo1 {
    /**
     * 
     * @type {SchemaInfoInterfaces}
     * @memberof SchemaInfo1
     */
    'interfaces'?: SchemaInfoInterfaces;
}
/**
 * Set the metadata format IDs.
 * @export
 * @interface SchemaInfoInterfaces
 */
export interface SchemaInfoInterfaces {
    /**
     * 
     * @type {Array<SchemaInfoInterfacesInInner>}
     * @memberof SchemaInfoInterfaces
     */
    'in'?: Array<SchemaInfoInterfacesInInner>;
}
/**
 * 
 * @export
 * @interface SchemaInfoInterfacesInInner
 */
export interface SchemaInfoInterfacesInInner {
    /**
     * Set the metadata format ID.
     * @type {string}
     * @memberof SchemaInfoInterfacesInInner
     */
    'metadataFormatId'?: string;
}
/**
 * 
 * @export
 * @interface SecondaryInterval
 */
export interface SecondaryInterval {
    /**
     * Interval at which to check for Config updates.Set in minutes.  0 : no Config. - Value definition   5 ~ 1440 :(24 hours)
     * @type {number}
     * @memberof SecondaryInterval
     */
    'ConfigInterval'?: number;
    /**
     * shooting interval. Set in minutes.  0 : no shooting. - Value definition   3 - 1440 :(24 hours)
     * @type {number}
     * @memberof SecondaryInterval
     */
    'CaptureInterval'?: number;
    /**
     * Reference time. (Hour: Minute) (Second is fixed at 00) - Value definition   \"00:00\" - \"23:59\"
     * @type {string}
     * @memberof SecondaryInterval
     */
    'BaseTime': string;
    /**
     * Upload the data after how many shots have been taken. Regarding Secondary, if 0, SecondaryInterval is disabled. Primary is fixed at 1. Secondary is 0 or 1.
     * @type {number}
     * @memberof SecondaryInterval
     */
    'UploadCount'?: number;
}
/**
 * SetDeviceLog JsonBody.
 * @export
 * @interface SetDeviceAppLogJsonBody
 */
export interface SetDeviceAppLogJsonBody {
    /**
     * Set logging enable/disable. - Value definition   true : enable   false : disable
     * @type {boolean}
     * @memberof SetDeviceAppLogJsonBody
     */
    'enable'?: boolean;
}
/**
 * Set the template configuration.
 * @export
 * @interface SetDeviceConfigurationJsonBody
 */
export interface SetDeviceConfigurationJsonBody {
    /**
     * 
     * @type {SetDeviceConfigurationJsonBodyPayload}
     * @memberof SetDeviceConfigurationJsonBody
     */
    'payload'?: SetDeviceConfigurationJsonBodyPayload;
}
/**
 * 
 * @export
 * @interface SetDeviceConfigurationJsonBodyPayload
 */
export interface SetDeviceConfigurationJsonBodyPayload {
    /**
     * 
     * @type {FWOperation}
     * @memberof SetDeviceConfigurationJsonBodyPayload
     */
    'FWOperation'?: FWOperation;
}
/**
 * SetImageConfiguration JsonBody.
 * @export
 * @interface SetImageConfigurationJsonBody
 */
export interface SetImageConfigurationJsonBody {
    /**
     * Set the frame rate. *Set an number value multiplied by 100 for the frame rate that comes up from the sensor. The maximum value of the frame rate depends on the value of DriveMode (see the Drive mode spec of drive_mode parameters for details). - Value definition   99   499   999   1248   1498   1998   2497   2997
     * @type {number}
     * @memberof SetImageConfigurationJsonBody
     */
    'frame_rate'?: number;
    /**
     * Set the drive mode. - Value definition   1   2   3   4 - Drive mode spec   <table>     <thead>       <tr>         <th>Mode</th>         <th>Binning</th>         <th>Scale</th>         <th>Crop</th>         <th>Raw Size</th>         <th>Max Frame Rate</th>       </tr>     </thead>     <tbody>       <tr>         <td>1</td>         <td>On</td>         <td>-</td>         <td>-</td>         <td>2028x1520</td>         <td>30(29.97)fps</td>       </tr>       <tr>         <td>2</td>         <td>Off</td>         <td>On</td>         <td>-</td>         <td>2028x1520</td>         <td>20(19.98)fps</td>       </tr>       <tr>         <td>3</td>         <td>Off</td>         <td>Off</td>         <td>On</td>         <td>2028x1520</td>         <td>20(19.98)fps</td>       </tr>       <tr>         <td>4</td>         <td>Off</td>         <td>Off</td>         <td>Off</td>         <td>4056x3040</td>         <td>10(9.99)fps</td>       </tr>     </tbody>   </table>
     * @type {number}
     * @memberof SetImageConfigurationJsonBody
     */
    'drive_mode'?: number;
}
/**
 * 
 * @export
 * @interface StartUploadInferenceResult200Response
 */
export interface StartUploadInferenceResult200Response {
    /**
     * Set \"SUCCESS\" fixing
     * @type {string}
     * @memberof StartUploadInferenceResult200Response
     */
    'result': string;
    /**
     * Input Image storage path, UploadMethod:BlobStorage only
     * @type {string}
     * @memberof StartUploadInferenceResult200Response
     */
    'outputSubDirectory'?: string;
    /**
     * Input Inference result storage path, UploadMethodIR:BlobStorage only
     * @type {string}
     * @memberof StartUploadInferenceResult200Response
     */
    'outputSubDirectoryIR'?: string;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * Set \"SUCCESS\" fixing.
     * @type {string}
     * @memberof SuccessResponse
     */
    'result': string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * Set the tag ID.
     * @type {string}
     * @memberof Tag
     */
    'tag_id'?: string;
    /**
     * Set the tag name.
     * @type {string}
     * @memberof Tag
     */
    'tag_name'?: string;
    /**
     * Set the tag description.
     * @type {string}
     * @memberof Tag
     */
    'tag_description'?: string;
    /**
     * Set the tag type.
     * @type {number}
     * @memberof Tag
     */
    'tag_type'?: number;
    /**
     * Set the number of tagged images.
     * @type {number}
     * @memberof Tag
     */
    'image_count'?: number;
}
/**
 * 
 * @export
 * @interface TrainingKit
 */
export interface TrainingKit {
    /**
     * Set the training kit ID.
     * @type {string}
     * @memberof TrainingKit
     */
    'id'?: string;
    /**
     * Set the training kit name.
     * @type {string}
     * @memberof TrainingKit
     */
    'name'?: string;
    /**
     * Set the tag description.
     * @type {string}
     * @memberof TrainingKit
     */
    'description'?: string;
    /**
     * Set the date the training kit was created.
     * @type {string}
     * @memberof TrainingKit
     */
    'created_on'?: string;
    /**
     * Set the status.
     * @type {string}
     * @memberof TrainingKit
     */
    'status'?: string;
    /**
     * Set the training kit type.
     * @type {string}
     * @memberof TrainingKit
     */
    'training_kit_type'?: string;
    /**
     * Set the default dataset split percentage.
     * @type {number}
     * @memberof TrainingKit
     */
    'default_dataset_split_percentage'?: number;
    /**
     * 
     * @type {TrainingKitFramework}
     * @memberof TrainingKit
     */
    'framework'?: TrainingKitFramework;
    /**
     * Set the owner.
     * @type {string}
     * @memberof TrainingKit
     */
    'owner'?: string;
    /**
     * Set whether or not to publish.
     * @type {boolean}
     * @memberof TrainingKit
     */
    'is_public'?: boolean;
}
/**
 * 
 * @export
 * @interface TrainingKitFramework
 */
export interface TrainingKitFramework {
    /**
     * Set the framework name.
     * @type {string}
     * @memberof TrainingKitFramework
     */
    'name'?: string;
    /**
     * Set the framework version.
     * @type {string}
     * @memberof TrainingKitFramework
     */
    'version'?: string;
}
/**
 * UnbindCommandParameterFileJsonBody Json Body
 * @export
 * @interface UnbindCommandParameterFileJsonBody
 */
export interface UnbindCommandParameterFileJsonBody {
    /**
     * Specify multiple device IDs separated by commas.
     * @type {string}
     * @memberof UnbindCommandParameterFileJsonBody
     */
    'device_ids': string;
}
/**
 * UpdateBaseModelVersion JsonBody.
 * @export
 * @interface UpdateBaseModelVersionJsonBody
 */
export interface UpdateBaseModelVersionJsonBody {
    /**
     * Description of version. Max. 100 characters.
     * @type {string}
     * @memberof UpdateBaseModelVersionJsonBody
     */
    'comment'?: string;
    /**
     * SAS URI or Presigned URI of the input format param file. *Usage: Packager conversion information (image format information). *The json format is an array of objects. Each object contains the following values. &nbsp; - ordinal: Order of DNN input to converter (value range: 0 to 2) &nbsp; - format: Format (\"RGB\" or \"BGR\") *Example: &nbsp;[{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"ordinal\": 0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"format\": \"RGB\" &nbsp;}, &nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"ordinal\": 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"format\": \"RGB\" &nbsp;}]
     * @type {string}
     * @memberof UpdateBaseModelVersionJsonBody
     */
    'input_format_param'?: string;
    /**
     * SAS URI or Presigned URI of the network config file. *Usage: Conversion parameter information of modelconverter. Therefore, it is not necessary to specify when specifying the model before conversion. *Example: &nbsp;{ &nbsp;&nbsp;&nbsp;\"Postprocessor\": { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"params\": { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"background\": false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"scale_factors\": [ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"score_thresh\": 0.01, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"max_size_per_class\": 64, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"max_total_size\": 64, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"clip_window\": [ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"iou_threshold\": 0.45 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;} &nbsp;}
     * @type {string}
     * @memberof UpdateBaseModelVersionJsonBody
     */
    'network_config'?: string;
}
/**
 * UpdateCommandParameterFile Json Body
 * @export
 * @interface UpdateCommandParameterFileBody
 */
export interface UpdateCommandParameterFileBody {
    /**
     * Command parameter content in base64 encoding. *See manual for detailed format
     * @type {string}
     * @memberof UpdateCommandParameterFileBody
     */
    'parameter': string;
    /**
     * Comment.
     * @type {string}
     * @memberof UpdateCommandParameterFileBody
     */
    'comment'?: string;
}
/**
 * UpdateDeviceCertificate Json Body
 * @export
 * @interface UpdateDeviceCertificateJsonBody
 */
export interface UpdateDeviceCertificateJsonBody {
    /**
     * Device certificate  X.509 primary certificate (.pem file or .cer file)  *Specify the following certificate without the leading and trailing signatures -----BEGIN CERTIFICATE-----  -----END CERTIFICATE-----  Also, do not include line breaks.
     * @type {string}
     * @memberof UpdateDeviceCertificateJsonBody
     */
    'primary_certificate': string;
}
/**
 * UpdateDeviceModelVersion JsonBody.
 * @export
 * @interface UpdateDeviceModelVersionJsonBody
 */
export interface UpdateDeviceModelVersionJsonBody {
    /**
     * Description of version.
     * @type {string}
     * @memberof UpdateDeviceModelVersionJsonBody
     */
    'comment': string;
}
/**
 * UpdateIRHubConnector JsonBody.
 * @export
 * @interface UpdateIRHubConnectorJsonBody
 */
export interface UpdateIRHubConnectorJsonBody {
    /**
     * Connection string for Azure Event Hubs forwarding inference result. *Do not specify when returning to the initial value. In the case of the initial value, it will be streamed within this service.
     * @type {string}
     * @memberof UpdateIRHubConnectorJsonBody
     */
    'url'?: string;
    /**
     * Azure Event Hubs namespace. *Do not specify when returning to the initial value. In the case of the initial value, it will be streamed within this service.
     * @type {string}
     * @memberof UpdateIRHubConnectorJsonBody
     */
    'name'?: string;
}
/**
 * UpdateProjectImageRegions JsonBody.
 * @export
 * @interface UpdateProjectImageRegionsJsonBody
 */
export interface UpdateProjectImageRegionsJsonBody {
    /**
     * 
     * @type {Array<RegionsInner>}
     * @memberof UpdateProjectImageRegionsJsonBody
     */
    'regions'?: Array<RegionsInner>;
}
/**
 * UpdateProjectTag JsonBody.
 * @export
 * @interface UpdateProjectTagJsonBody
 */
export interface UpdateProjectTagJsonBody {
    /**
     * Name.
     * @type {string}
     * @memberof UpdateProjectTagJsonBody
     */
    'name': string;
    /**
     * Description.
     * @type {string}
     * @memberof UpdateProjectTagJsonBody
     */
    'description'?: string;
    /**
     * type. *Specify Regular as fixed.
     * @type {string}
     * @memberof UpdateProjectTagJsonBody
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface UploadInferenceParameter
 */
export interface UploadInferenceParameter {
    /**
     * Only BlobStorage is supported.
     * @type {string}
     * @memberof UploadInferenceParameter
     */
    'UploadMethodIR'?: string;
    /**
     * Maximum 64 characters
     * @type {string}
     * @memberof UploadInferenceParameter
     */
    'StorageNameIR': string;
    /**
     * Maximum 256 characters
     * @type {string}
     * @memberof UploadInferenceParameter
     */
    'StorageSubDirectoryPathIR': string;
    /**
     * Maximum 1364 characters. Please add base64 Encoding to PPLparameter.
     * @type {string}
     * @memberof UploadInferenceParameter
     */
    'PPLParameter'?: string;
    /**
     * - Value definition   0 ~ 4055
     * @type {number}
     * @memberof UploadInferenceParameter
     */
    'CropHOffset'?: number;
    /**
     * - Value definition   0 ~ 3039
     * @type {number}
     * @memberof UploadInferenceParameter
     */
    'CropVOffset'?: number;
    /**
     * - Value definition   0 ~ 4056
     * @type {number}
     * @memberof UploadInferenceParameter
     */
    'CropHSize'?: number;
    /**
     * - Value definition   0 ~ 3040
     * @type {number}
     * @memberof UploadInferenceParameter
     */
    'CropVSize'?: number;
    /**
     * Empty characters are also allowed. The operation in the case of an empty string is as follows. A. If the number of arrays notified by Version.DnnModelVersion is 1 or more, it works with the DNN model of the first element. B. If the number of arrays notified by Version.DnnModelVersion is 0, it will be treated as an invalid parameter, it will sleep immediately, and the next startup will operate in Config mode. - Value definition   \"000000\" ~ \"999999\"
     * @type {string}
     * @memberof UploadInferenceParameter
     */
    'NetworkId'?: string;
}
/**
 * 
 * @export
 * @interface VafeLog
 */
export interface VafeLog {
    /**
     * Set the log ID.
     * @type {string}
     * @memberof VafeLog
     */
    'id'?: string;
    /**
     * Set the log message.
     * @type {string}
     * @memberof VafeLog
     */
    'log'?: string;
    /**
     * Set the app instance name.
     * @type {string}
     * @memberof VafeLog
     */
    'app'?: string;
    /**
     * Set the stream type.
     * @type {string}
     * @memberof VafeLog
     */
    'stream'?: string;
    /**
     * Set the log time.
     * @type {string}
     * @memberof VafeLog
     */
    'time'?: string;
    /**
     * Set the log time ingested in system.
     * @type {string}
     * @memberof VafeLog
     */
    'ingestion_time'?: string;
}

/**
 * CommandParameterFileApi - axios parameter creator
 * @export
 */
export const CommandParameterFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bind command parameter file to device.
         * @summary BindCommandParameterFileToDevice
         * @param {string} fileName Filename.
         * @param {BindCommandParameterFileToDeviceJsonBody} bindCommandParameterFileToDeviceJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindCommandParameterFileToDevice: async (fileName: string, bindCommandParameterFileToDeviceJsonBody: BindCommandParameterFileToDeviceJsonBody, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('bindCommandParameterFileToDevice', 'fileName', fileName)
            // verify required parameter 'bindCommandParameterFileToDeviceJsonBody' is not null or undefined
            assertParamExists('bindCommandParameterFileToDevice', 'bindCommandParameterFileToDeviceJsonBody', bindCommandParameterFileToDeviceJsonBody)
            const localVarPath = `/devices/configuration/command_parameter_files/{file_name}`
                .replace(`{${"file_name"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bindCommandParameterFileToDeviceJsonBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the command parameter file list information..
         * @summary GetCommandParameterFile
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandParameterFile: async (grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/command_parameter_files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register CommandParameterFile.  This API can be used to register the following API parameters in advance: - StartUploadInferenceData API  The following are the APIs for file management and application to the device:  < Parameter file management > - RegistCommandParameterFile API - GetCommandParameterFile API - UpdateCommandParameterFile API - DeleteCommandParameterFile API  < Bind to/Unbind from device > - BindCommandParameterFileToDevice API - UnbindCommandParameterFile API  If the parameter file is not applied to the device, operate using the default value. APIs with required parameters will result in an error when the API is executed. The default file can be specified using the following API: - SetDefaultCommandParameterFile API
         * @summary RegistCommandParameterFile
         * @param {RegistCommandParameterFileBody} registCommandParameterFileBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registCommandParameterFile: async (registCommandParameterFileBody: RegistCommandParameterFileBody, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registCommandParameterFileBody' is not null or undefined
            assertParamExists('registCommandParameterFile', 'registCommandParameterFileBody', registCommandParameterFileBody)
            const localVarPath = `/command_parameter_files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registCommandParameterFileBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unbind command parameter file.
         * @summary UnbindCommandParameterFile
         * @param {string} fileName Filename.
         * @param {UnbindCommandParameterFileJsonBody} unbindCommandParameterFileJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindCommandParameterFile: async (fileName: string, unbindCommandParameterFileJsonBody: UnbindCommandParameterFileJsonBody, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('unbindCommandParameterFile', 'fileName', fileName)
            // verify required parameter 'unbindCommandParameterFileJsonBody' is not null or undefined
            assertParamExists('unbindCommandParameterFile', 'unbindCommandParameterFileJsonBody', unbindCommandParameterFileJsonBody)
            const localVarPath = `/devices/configuration/command_parameter_files/{file_name}`
                .replace(`{${"file_name"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unbindCommandParameterFileJsonBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update command parameter file.
         * @summary UpdateCommandParameterFile
         * @param {string} fileName Filename.
         * @param {UpdateCommandParameterFileBody} updateCommandParameterFileBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommandParameterFile: async (fileName: string, updateCommandParameterFileBody: UpdateCommandParameterFileBody, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('updateCommandParameterFile', 'fileName', fileName)
            // verify required parameter 'updateCommandParameterFileBody' is not null or undefined
            assertParamExists('updateCommandParameterFile', 'updateCommandParameterFileBody', updateCommandParameterFileBody)
            const localVarPath = `/command_parameter_files/{file_name}`
                .replace(`{${"file_name"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCommandParameterFileBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandParameterFileApi - functional programming interface
 * @export
 */
export const CommandParameterFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandParameterFileApiAxiosParamCreator(configuration)
    return {
        /**
         * Bind command parameter file to device.
         * @summary BindCommandParameterFileToDevice
         * @param {string} fileName Filename.
         * @param {BindCommandParameterFileToDeviceJsonBody} bindCommandParameterFileToDeviceJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindCommandParameterFileToDevice(fileName: string, bindCommandParameterFileToDeviceJsonBody: BindCommandParameterFileToDeviceJsonBody, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindCommandParameterFileToDevice(fileName, bindCommandParameterFileToDeviceJsonBody, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the command parameter file list information..
         * @summary GetCommandParameterFile
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommandParameterFile(grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommandParameterFile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommandParameterFile(grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register CommandParameterFile.  This API can be used to register the following API parameters in advance: - StartUploadInferenceData API  The following are the APIs for file management and application to the device:  < Parameter file management > - RegistCommandParameterFile API - GetCommandParameterFile API - UpdateCommandParameterFile API - DeleteCommandParameterFile API  < Bind to/Unbind from device > - BindCommandParameterFileToDevice API - UnbindCommandParameterFile API  If the parameter file is not applied to the device, operate using the default value. APIs with required parameters will result in an error when the API is executed. The default file can be specified using the following API: - SetDefaultCommandParameterFile API
         * @summary RegistCommandParameterFile
         * @param {RegistCommandParameterFileBody} registCommandParameterFileBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registCommandParameterFile(registCommandParameterFileBody: RegistCommandParameterFileBody, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registCommandParameterFile(registCommandParameterFileBody, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unbind command parameter file.
         * @summary UnbindCommandParameterFile
         * @param {string} fileName Filename.
         * @param {UnbindCommandParameterFileJsonBody} unbindCommandParameterFileJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindCommandParameterFile(fileName: string, unbindCommandParameterFileJsonBody: UnbindCommandParameterFileJsonBody, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindCommandParameterFile(fileName, unbindCommandParameterFileJsonBody, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update command parameter file.
         * @summary UpdateCommandParameterFile
         * @param {string} fileName Filename.
         * @param {UpdateCommandParameterFileBody} updateCommandParameterFileBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCommandParameterFile(fileName: string, updateCommandParameterFileBody: UpdateCommandParameterFileBody, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCommandParameterFile(fileName, updateCommandParameterFileBody, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommandParameterFileApi - factory interface
 * @export
 */
export const CommandParameterFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandParameterFileApiFp(configuration)
    return {
        /**
         * Bind command parameter file to device.
         * @summary BindCommandParameterFileToDevice
         * @param {string} fileName Filename.
         * @param {BindCommandParameterFileToDeviceJsonBody} bindCommandParameterFileToDeviceJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindCommandParameterFileToDevice(fileName: string, bindCommandParameterFileToDeviceJsonBody: BindCommandParameterFileToDeviceJsonBody, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.bindCommandParameterFileToDevice(fileName, bindCommandParameterFileToDeviceJsonBody, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the command parameter file list information..
         * @summary GetCommandParameterFile
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandParameterFile(grantType?: string, options?: any): AxiosPromise<GetCommandParameterFile200Response> {
            return localVarFp.getCommandParameterFile(grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Register CommandParameterFile.  This API can be used to register the following API parameters in advance: - StartUploadInferenceData API  The following are the APIs for file management and application to the device:  < Parameter file management > - RegistCommandParameterFile API - GetCommandParameterFile API - UpdateCommandParameterFile API - DeleteCommandParameterFile API  < Bind to/Unbind from device > - BindCommandParameterFileToDevice API - UnbindCommandParameterFile API  If the parameter file is not applied to the device, operate using the default value. APIs with required parameters will result in an error when the API is executed. The default file can be specified using the following API: - SetDefaultCommandParameterFile API
         * @summary RegistCommandParameterFile
         * @param {RegistCommandParameterFileBody} registCommandParameterFileBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registCommandParameterFile(registCommandParameterFileBody: RegistCommandParameterFileBody, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.registCommandParameterFile(registCommandParameterFileBody, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Unbind command parameter file.
         * @summary UnbindCommandParameterFile
         * @param {string} fileName Filename.
         * @param {UnbindCommandParameterFileJsonBody} unbindCommandParameterFileJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindCommandParameterFile(fileName: string, unbindCommandParameterFileJsonBody: UnbindCommandParameterFileJsonBody, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.unbindCommandParameterFile(fileName, unbindCommandParameterFileJsonBody, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Update command parameter file.
         * @summary UpdateCommandParameterFile
         * @param {string} fileName Filename.
         * @param {UpdateCommandParameterFileBody} updateCommandParameterFileBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommandParameterFile(fileName: string, updateCommandParameterFileBody: UpdateCommandParameterFileBody, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateCommandParameterFile(fileName, updateCommandParameterFileBody, grantType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandParameterFileApi - object-oriented interface
 * @export
 * @class CommandParameterFileApi
 * @extends {BaseAPI}
 */
export class CommandParameterFileApi extends BaseAPI {
    /**
     * Bind command parameter file to device.
     * @summary BindCommandParameterFileToDevice
     * @param {string} fileName Filename.
     * @param {BindCommandParameterFileToDeviceJsonBody} bindCommandParameterFileToDeviceJsonBody 
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandParameterFileApi
     */
    public bindCommandParameterFileToDevice(fileName: string, bindCommandParameterFileToDeviceJsonBody: BindCommandParameterFileToDeviceJsonBody, grantType?: string, options?: AxiosRequestConfig) {
        return CommandParameterFileApiFp(this.configuration).bindCommandParameterFileToDevice(fileName, bindCommandParameterFileToDeviceJsonBody, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the command parameter file list information..
     * @summary GetCommandParameterFile
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandParameterFileApi
     */
    public getCommandParameterFile(grantType?: string, options?: AxiosRequestConfig) {
        return CommandParameterFileApiFp(this.configuration).getCommandParameterFile(grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register CommandParameterFile.  This API can be used to register the following API parameters in advance: - StartUploadInferenceData API  The following are the APIs for file management and application to the device:  < Parameter file management > - RegistCommandParameterFile API - GetCommandParameterFile API - UpdateCommandParameterFile API - DeleteCommandParameterFile API  < Bind to/Unbind from device > - BindCommandParameterFileToDevice API - UnbindCommandParameterFile API  If the parameter file is not applied to the device, operate using the default value. APIs with required parameters will result in an error when the API is executed. The default file can be specified using the following API: - SetDefaultCommandParameterFile API
     * @summary RegistCommandParameterFile
     * @param {RegistCommandParameterFileBody} registCommandParameterFileBody 
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandParameterFileApi
     */
    public registCommandParameterFile(registCommandParameterFileBody: RegistCommandParameterFileBody, grantType?: string, options?: AxiosRequestConfig) {
        return CommandParameterFileApiFp(this.configuration).registCommandParameterFile(registCommandParameterFileBody, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unbind command parameter file.
     * @summary UnbindCommandParameterFile
     * @param {string} fileName Filename.
     * @param {UnbindCommandParameterFileJsonBody} unbindCommandParameterFileJsonBody 
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandParameterFileApi
     */
    public unbindCommandParameterFile(fileName: string, unbindCommandParameterFileJsonBody: UnbindCommandParameterFileJsonBody, grantType?: string, options?: AxiosRequestConfig) {
        return CommandParameterFileApiFp(this.configuration).unbindCommandParameterFile(fileName, unbindCommandParameterFileJsonBody, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update command parameter file.
     * @summary UpdateCommandParameterFile
     * @param {string} fileName Filename.
     * @param {UpdateCommandParameterFileBody} updateCommandParameterFileBody 
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandParameterFileApi
     */
    public updateCommandParameterFile(fileName: string, updateCommandParameterFileBody: UpdateCommandParameterFileBody, grantType?: string, options?: AxiosRequestConfig) {
        return CommandParameterFileApiFp(this.configuration).updateCommandParameterFile(fileName, updateCommandParameterFileBody, grantType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeployApi - axios parameter creator
 * @export
 */
export const DeployApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Force cancellation of the device deployment status.
         * @summary CancelDeployment
         * @param {string} deviceId Device ID
         * @param {string} deployId Deploy ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDeployment: async (deviceId: string, deployId: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('cancelDeployment', 'deviceId', deviceId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('cancelDeployment', 'deployId', deployId)
            const localVarPath = `/devices/{device_id}/deploys/{deploy_id}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"deploy_id"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register the deploy config information to deploy to the following devices. - Firmware - AI model
         * @summary CreateDeployConfiguration
         * @param {string} configId Max. 20 single characters, single-byte characters only.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [comment] Max. 100 characters.
         * @param {string} [sensorLoaderVersionNumber] Sensor loader version number.
         * @param {string} [sensorVersionNumber] Sensor version number.
         * @param {string} [modelId] Model ID.
         * @param {string} [modelVersionNumber] Model version number.
         * @param {string} [apFwVersionNumber] AppFw version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployConfiguration: async (configId: string, grantType?: string, comment?: string, sensorLoaderVersionNumber?: string, sensorVersionNumber?: string, modelId?: string, modelVersionNumber?: string, apFwVersionNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configId' is not null or undefined
            assertParamExists('createDeployConfiguration', 'configId', configId)
            const localVarPath = `/deployconfigurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (configId !== undefined) {
                localVarQueryParameter['config_id'] = configId;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (sensorLoaderVersionNumber !== undefined) {
                localVarQueryParameter['sensor_loader_version_number'] = sensorLoaderVersionNumber;
            }

            if (sensorVersionNumber !== undefined) {
                localVarQueryParameter['sensor_version_number'] = sensorVersionNumber;
            }

            if (modelId !== undefined) {
                localVarQueryParameter['model_id'] = modelId;
            }

            if (modelVersionNumber !== undefined) {
                localVarQueryParameter['model_version_number'] = modelVersionNumber;
            }

            if (apFwVersionNumber !== undefined) {
                localVarQueryParameter['ap_fw_version_number'] = apFwVersionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the information for a specified deploy config.
         * @summary DeleteDeployConfiguration
         * @param {string} configId Config ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployConfiguration: async (configId: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configId' is not null or undefined
            assertParamExists('deleteDeployConfiguration', 'configId', configId)
            const localVarPath = `/deployconfigurations/{config_id}`
                .replace(`{${"config_id"}}`, encodeURIComponent(String(configId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Provide a function for deploying the following to devices specified with deploy config.    - Firmware    - AI model
         * @summary DeployByConfiguration
         * @param {string} configId Setting ID.
         * @param {string} deviceIds Specify multiple device IDs separated by commas.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [replaceModelId] Specify the model ID or network_id. *If the model with the specified model ID does not exist in the database, treat the entered value as the network_id and process it.
         * @param {string} [comment] Max. 100 characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployByConfiguration: async (configId: string, deviceIds: string, grantType?: string, replaceModelId?: string, comment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configId' is not null or undefined
            assertParamExists('deployByConfiguration', 'configId', configId)
            // verify required parameter 'deviceIds' is not null or undefined
            assertParamExists('deployByConfiguration', 'deviceIds', deviceIds)
            const localVarPath = `/deployconfigurations/{config_id}`
                .replace(`{${"config_id"}}`, encodeURIComponent(String(configId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (deviceIds !== undefined) {
                localVarQueryParameter['device_ids'] = deviceIds;
            }

            if (replaceModelId !== undefined) {
                localVarQueryParameter['replace_model_id'] = replaceModelId;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the deploy config list.
         * @summary GetDeployConfigurations
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployConfigurations: async (grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deployconfigurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the deploy history for a specified device.
         * @summary GetDeployHistory
         * @param {string} deviceId Device ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployHistory: async (deviceId: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getDeployHistory', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/deploys`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeployApi - functional programming interface
 * @export
 */
export const DeployApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeployApiAxiosParamCreator(configuration)
    return {
        /**
         * Force cancellation of the device deployment status.
         * @summary CancelDeployment
         * @param {string} deviceId Device ID
         * @param {string} deployId Deploy ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelDeployment(deviceId: string, deployId: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelDeployment(deviceId, deployId, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register the deploy config information to deploy to the following devices. - Firmware - AI model
         * @summary CreateDeployConfiguration
         * @param {string} configId Max. 20 single characters, single-byte characters only.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [comment] Max. 100 characters.
         * @param {string} [sensorLoaderVersionNumber] Sensor loader version number.
         * @param {string} [sensorVersionNumber] Sensor version number.
         * @param {string} [modelId] Model ID.
         * @param {string} [modelVersionNumber] Model version number.
         * @param {string} [apFwVersionNumber] AppFw version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeployConfiguration(configId: string, grantType?: string, comment?: string, sensorLoaderVersionNumber?: string, sensorVersionNumber?: string, modelId?: string, modelVersionNumber?: string, apFwVersionNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeployConfiguration(configId, grantType, comment, sensorLoaderVersionNumber, sensorVersionNumber, modelId, modelVersionNumber, apFwVersionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the information for a specified deploy config.
         * @summary DeleteDeployConfiguration
         * @param {string} configId Config ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeployConfiguration(configId: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeployConfiguration(configId, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *    Provide a function for deploying the following to devices specified with deploy config.    - Firmware    - AI model
         * @summary DeployByConfiguration
         * @param {string} configId Setting ID.
         * @param {string} deviceIds Specify multiple device IDs separated by commas.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [replaceModelId] Specify the model ID or network_id. *If the model with the specified model ID does not exist in the database, treat the entered value as the network_id and process it.
         * @param {string} [comment] Max. 100 characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployByConfiguration(configId: string, deviceIds: string, grantType?: string, replaceModelId?: string, comment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployByConfiguration(configId, deviceIds, grantType, replaceModelId, comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the deploy config list.
         * @summary GetDeployConfigurations
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployConfigurations(grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeployConfigurations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployConfigurations(grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the deploy history for a specified device.
         * @summary GetDeployHistory
         * @param {string} deviceId Device ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployHistory(deviceId: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeployHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployHistory(deviceId, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeployApi - factory interface
 * @export
 */
export const DeployApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeployApiFp(configuration)
    return {
        /**
         * Force cancellation of the device deployment status.
         * @summary CancelDeployment
         * @param {string} deviceId Device ID
         * @param {string} deployId Deploy ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDeployment(deviceId: string, deployId: string, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.cancelDeployment(deviceId, deployId, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Register the deploy config information to deploy to the following devices. - Firmware - AI model
         * @summary CreateDeployConfiguration
         * @param {string} configId Max. 20 single characters, single-byte characters only.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [comment] Max. 100 characters.
         * @param {string} [sensorLoaderVersionNumber] Sensor loader version number.
         * @param {string} [sensorVersionNumber] Sensor version number.
         * @param {string} [modelId] Model ID.
         * @param {string} [modelVersionNumber] Model version number.
         * @param {string} [apFwVersionNumber] AppFw version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployConfiguration(configId: string, grantType?: string, comment?: string, sensorLoaderVersionNumber?: string, sensorVersionNumber?: string, modelId?: string, modelVersionNumber?: string, apFwVersionNumber?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.createDeployConfiguration(configId, grantType, comment, sensorLoaderVersionNumber, sensorVersionNumber, modelId, modelVersionNumber, apFwVersionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the information for a specified deploy config.
         * @summary DeleteDeployConfiguration
         * @param {string} configId Config ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployConfiguration(configId: string, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteDeployConfiguration(configId, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         *    Provide a function for deploying the following to devices specified with deploy config.    - Firmware    - AI model
         * @summary DeployByConfiguration
         * @param {string} configId Setting ID.
         * @param {string} deviceIds Specify multiple device IDs separated by commas.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [replaceModelId] Specify the model ID or network_id. *If the model with the specified model ID does not exist in the database, treat the entered value as the network_id and process it.
         * @param {string} [comment] Max. 100 characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployByConfiguration(configId: string, deviceIds: string, grantType?: string, replaceModelId?: string, comment?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deployByConfiguration(configId, deviceIds, grantType, replaceModelId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the deploy config list.
         * @summary GetDeployConfigurations
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployConfigurations(grantType?: string, options?: any): AxiosPromise<GetDeployConfigurations200Response> {
            return localVarFp.getDeployConfigurations(grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the deploy history for a specified device.
         * @summary GetDeployHistory
         * @param {string} deviceId Device ID
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployHistory(deviceId: string, grantType?: string, options?: any): AxiosPromise<GetDeployHistory200Response> {
            return localVarFp.getDeployHistory(deviceId, grantType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeployApi - object-oriented interface
 * @export
 * @class DeployApi
 * @extends {BaseAPI}
 */
export class DeployApi extends BaseAPI {
    /**
     * Force cancellation of the device deployment status.
     * @summary CancelDeployment
     * @param {string} deviceId Device ID
     * @param {string} deployId Deploy ID
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployApi
     */
    public cancelDeployment(deviceId: string, deployId: string, grantType?: string, options?: AxiosRequestConfig) {
        return DeployApiFp(this.configuration).cancelDeployment(deviceId, deployId, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register the deploy config information to deploy to the following devices. - Firmware - AI model
     * @summary CreateDeployConfiguration
     * @param {string} configId Max. 20 single characters, single-byte characters only.
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [comment] Max. 100 characters.
     * @param {string} [sensorLoaderVersionNumber] Sensor loader version number.
     * @param {string} [sensorVersionNumber] Sensor version number.
     * @param {string} [modelId] Model ID.
     * @param {string} [modelVersionNumber] Model version number.
     * @param {string} [apFwVersionNumber] AppFw version number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployApi
     */
    public createDeployConfiguration(configId: string, grantType?: string, comment?: string, sensorLoaderVersionNumber?: string, sensorVersionNumber?: string, modelId?: string, modelVersionNumber?: string, apFwVersionNumber?: string, options?: AxiosRequestConfig) {
        return DeployApiFp(this.configuration).createDeployConfiguration(configId, grantType, comment, sensorLoaderVersionNumber, sensorVersionNumber, modelId, modelVersionNumber, apFwVersionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the information for a specified deploy config.
     * @summary DeleteDeployConfiguration
     * @param {string} configId Config ID
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployApi
     */
    public deleteDeployConfiguration(configId: string, grantType?: string, options?: AxiosRequestConfig) {
        return DeployApiFp(this.configuration).deleteDeployConfiguration(configId, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Provide a function for deploying the following to devices specified with deploy config.    - Firmware    - AI model
     * @summary DeployByConfiguration
     * @param {string} configId Setting ID.
     * @param {string} deviceIds Specify multiple device IDs separated by commas.
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [replaceModelId] Specify the model ID or network_id. *If the model with the specified model ID does not exist in the database, treat the entered value as the network_id and process it.
     * @param {string} [comment] Max. 100 characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployApi
     */
    public deployByConfiguration(configId: string, deviceIds: string, grantType?: string, replaceModelId?: string, comment?: string, options?: AxiosRequestConfig) {
        return DeployApiFp(this.configuration).deployByConfiguration(configId, deviceIds, grantType, replaceModelId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the deploy config list.
     * @summary GetDeployConfigurations
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployApi
     */
    public getDeployConfigurations(grantType?: string, options?: AxiosRequestConfig) {
        return DeployApiFp(this.configuration).getDeployConfigurations(grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the deploy history for a specified device.
     * @summary GetDeployHistory
     * @param {string} deviceId Device ID
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployApi
     */
    public getDeployHistory(deviceId: string, grantType?: string, options?: AxiosRequestConfig) {
        return DeployApiFp(this.configuration).getDeployHistory(deviceId, grantType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceAppApi - axios parameter creator
 * @export
 */
export const DeviceAppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete device app.
         * @summary DeleteDeviceApp
         * @param {string} appName App name.
         * @param {string} versionNumber App version number.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceApp: async (appName: string, versionNumber: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appName' is not null or undefined
            assertParamExists('deleteDeviceApp', 'appName', appName)
            // verify required parameter 'versionNumber' is not null or undefined
            assertParamExists('deleteDeviceApp', 'versionNumber', versionNumber)
            const localVarPath = `/device_apps/{app_name}/{version_number}`
                .replace(`{${"app_name"}}`, encodeURIComponent(String(appName)))
                .replace(`{${"version_number"}}`, encodeURIComponent(String(versionNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy device app.
         * @summary DeployDeviceApp
         * @param {DeployDeviceAppJsonBody} deployDeviceAppJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDeviceApp: async (deployDeviceAppJsonBody: DeployDeviceAppJsonBody, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deployDeviceAppJsonBody' is not null or undefined
            assertParamExists('deployDeviceApp', 'deployDeviceAppJsonBody', deployDeviceAppJsonBody)
            const localVarPath = `/device_apps_deploys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployDeviceAppJsonBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Device App Deploys.
         * @summary GetDeviceAppDeploys
         * @param {string} appName App name
         * @param {string} versionNumber App version number
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAppDeploys: async (appName: string, versionNumber: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appName' is not null or undefined
            assertParamExists('getDeviceAppDeploys', 'appName', appName)
            // verify required parameter 'versionNumber' is not null or undefined
            assertParamExists('getDeviceAppDeploys', 'versionNumber', versionNumber)
            const localVarPath = `/device_apps/{app_name}/{version_number}/deploys`
                .replace(`{${"app_name"}}`, encodeURIComponent(String(appName)))
                .replace(`{${"version_number"}}`, encodeURIComponent(String(versionNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the device app list information.
         * @summary GetDeviceApps
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceApps: async (grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device_apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import Device app.
         * @summary ImportDeviceApp
         * @param {ImportDeviceAppJsonBody} importDeviceAppJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDeviceApp: async (importDeviceAppJsonBody: ImportDeviceAppJsonBody, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importDeviceAppJsonBody' is not null or undefined
            assertParamExists('importDeviceApp', 'importDeviceAppJsonBody', importDeviceAppJsonBody)
            const localVarPath = `/device_apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importDeviceAppJsonBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Undeploy device app.
         * @summary UndeployDeviceApp
         * @param {string} deviceIds Device IDs
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployDeviceApp: async (deviceIds: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceIds' is not null or undefined
            assertParamExists('undeployDeviceApp', 'deviceIds', deviceIds)
            const localVarPath = `/device_apps_deploys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (deviceIds !== undefined) {
                localVarQueryParameter['device_ids'] = deviceIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceAppApi - functional programming interface
 * @export
 */
export const DeviceAppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceAppApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete device app.
         * @summary DeleteDeviceApp
         * @param {string} appName App name.
         * @param {string} versionNumber App version number.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceApp(appName: string, versionNumber: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceApp(appName, versionNumber, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy device app.
         * @summary DeployDeviceApp
         * @param {DeployDeviceAppJsonBody} deployDeviceAppJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployDeviceApp(deployDeviceAppJsonBody: DeployDeviceAppJsonBody, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployDeviceApp(deployDeviceAppJsonBody, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Device App Deploys.
         * @summary GetDeviceAppDeploys
         * @param {string} appName App name
         * @param {string} versionNumber App version number
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAppDeploys(appName: string, versionNumber: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeviceAppDeploys200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAppDeploys(appName, versionNumber, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the device app list information.
         * @summary GetDeviceApps
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceApps(grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeviceApps200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceApps(grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import Device app.
         * @summary ImportDeviceApp
         * @param {ImportDeviceAppJsonBody} importDeviceAppJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importDeviceApp(importDeviceAppJsonBody: ImportDeviceAppJsonBody, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importDeviceApp(importDeviceAppJsonBody, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Undeploy device app.
         * @summary UndeployDeviceApp
         * @param {string} deviceIds Device IDs
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undeployDeviceApp(deviceIds: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undeployDeviceApp(deviceIds, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceAppApi - factory interface
 * @export
 */
export const DeviceAppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceAppApiFp(configuration)
    return {
        /**
         * Delete device app.
         * @summary DeleteDeviceApp
         * @param {string} appName App name.
         * @param {string} versionNumber App version number.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceApp(appName: string, versionNumber: string, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteDeviceApp(appName, versionNumber, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy device app.
         * @summary DeployDeviceApp
         * @param {DeployDeviceAppJsonBody} deployDeviceAppJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDeviceApp(deployDeviceAppJsonBody: DeployDeviceAppJsonBody, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deployDeviceApp(deployDeviceAppJsonBody, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Device App Deploys.
         * @summary GetDeviceAppDeploys
         * @param {string} appName App name
         * @param {string} versionNumber App version number
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAppDeploys(appName: string, versionNumber: string, grantType?: string, options?: any): AxiosPromise<GetDeviceAppDeploys200Response> {
            return localVarFp.getDeviceAppDeploys(appName, versionNumber, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the device app list information.
         * @summary GetDeviceApps
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceApps(grantType?: string, options?: any): AxiosPromise<GetDeviceApps200Response> {
            return localVarFp.getDeviceApps(grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Import Device app.
         * @summary ImportDeviceApp
         * @param {ImportDeviceAppJsonBody} importDeviceAppJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDeviceApp(importDeviceAppJsonBody: ImportDeviceAppJsonBody, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.importDeviceApp(importDeviceAppJsonBody, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Undeploy device app.
         * @summary UndeployDeviceApp
         * @param {string} deviceIds Device IDs
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeployDeviceApp(deviceIds: string, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.undeployDeviceApp(deviceIds, grantType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceAppApi - object-oriented interface
 * @export
 * @class DeviceAppApi
 * @extends {BaseAPI}
 */
export class DeviceAppApi extends BaseAPI {
    /**
     * Delete device app.
     * @summary DeleteDeviceApp
     * @param {string} appName App name.
     * @param {string} versionNumber App version number.
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceAppApi
     */
    public deleteDeviceApp(appName: string, versionNumber: string, grantType?: string, options?: AxiosRequestConfig) {
        return DeviceAppApiFp(this.configuration).deleteDeviceApp(appName, versionNumber, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy device app.
     * @summary DeployDeviceApp
     * @param {DeployDeviceAppJsonBody} deployDeviceAppJsonBody 
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceAppApi
     */
    public deployDeviceApp(deployDeviceAppJsonBody: DeployDeviceAppJsonBody, grantType?: string, options?: AxiosRequestConfig) {
        return DeviceAppApiFp(this.configuration).deployDeviceApp(deployDeviceAppJsonBody, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Device App Deploys.
     * @summary GetDeviceAppDeploys
     * @param {string} appName App name
     * @param {string} versionNumber App version number
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceAppApi
     */
    public getDeviceAppDeploys(appName: string, versionNumber: string, grantType?: string, options?: AxiosRequestConfig) {
        return DeviceAppApiFp(this.configuration).getDeviceAppDeploys(appName, versionNumber, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the device app list information.
     * @summary GetDeviceApps
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceAppApi
     */
    public getDeviceApps(grantType?: string, options?: AxiosRequestConfig) {
        return DeviceAppApiFp(this.configuration).getDeviceApps(grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import Device app.
     * @summary ImportDeviceApp
     * @param {ImportDeviceAppJsonBody} importDeviceAppJsonBody 
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceAppApi
     */
    public importDeviceApp(importDeviceAppJsonBody: ImportDeviceAppJsonBody, grantType?: string, options?: AxiosRequestConfig) {
        return DeviceAppApiFp(this.configuration).importDeviceApp(importDeviceAppJsonBody, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Undeploy device app.
     * @summary UndeployDeviceApp
     * @param {string} deviceIds Device IDs
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceAppApi
     */
    public undeployDeviceApp(deviceIds: string, grantType?: string, options?: AxiosRequestConfig) {
        return DeviceAppApiFp(this.configuration).undeployDeviceApp(deviceIds, grantType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceCommandApi - axios parameter creator
 * @export
 */
export const DeviceCommandApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Implement instructions to a specified device to start to get the inference result metadata (Output Tensor) and image (Input image).
         * @summary StartUploadInferenceResult
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startUploadInferenceResult: async (deviceId: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('startUploadInferenceResult', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/inferenceresults/collectstart`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Implement instructions to a specified device to stop getting the inference result metadata (Output Tensor) and image (Input image).
         * @summary StopUploadInferenceResult
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopUploadInferenceResult: async (deviceId: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('stopUploadInferenceResult', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/inferenceresults/collectstop`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceCommandApi - functional programming interface
 * @export
 */
export const DeviceCommandApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceCommandApiAxiosParamCreator(configuration)
    return {
        /**
         * Implement instructions to a specified device to start to get the inference result metadata (Output Tensor) and image (Input image).
         * @summary StartUploadInferenceResult
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startUploadInferenceResult(deviceId: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartUploadInferenceResult200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startUploadInferenceResult(deviceId, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Implement instructions to a specified device to stop getting the inference result metadata (Output Tensor) and image (Input image).
         * @summary StopUploadInferenceResult
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopUploadInferenceResult(deviceId: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopUploadInferenceResult(deviceId, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceCommandApi - factory interface
 * @export
 */
export const DeviceCommandApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceCommandApiFp(configuration)
    return {
        /**
         * Implement instructions to a specified device to start to get the inference result metadata (Output Tensor) and image (Input image).
         * @summary StartUploadInferenceResult
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startUploadInferenceResult(deviceId: string, grantType?: string, options?: any): AxiosPromise<StartUploadInferenceResult200Response> {
            return localVarFp.startUploadInferenceResult(deviceId, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Implement instructions to a specified device to stop getting the inference result metadata (Output Tensor) and image (Input image).
         * @summary StopUploadInferenceResult
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopUploadInferenceResult(deviceId: string, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.stopUploadInferenceResult(deviceId, grantType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceCommandApi - object-oriented interface
 * @export
 * @class DeviceCommandApi
 * @extends {BaseAPI}
 */
export class DeviceCommandApi extends BaseAPI {
    /**
     * Implement instructions to a specified device to start to get the inference result metadata (Output Tensor) and image (Input image).
     * @summary StartUploadInferenceResult
     * @param {string} deviceId Device ID.
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceCommandApi
     */
    public startUploadInferenceResult(deviceId: string, grantType?: string, options?: AxiosRequestConfig) {
        return DeviceCommandApiFp(this.configuration).startUploadInferenceResult(deviceId, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Implement instructions to a specified device to stop getting the inference result metadata (Output Tensor) and image (Input image).
     * @summary StopUploadInferenceResult
     * @param {string} deviceId Device ID.
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceCommandApi
     */
    public stopUploadInferenceResult(deviceId: string, grantType?: string, options?: AxiosRequestConfig) {
        return DeviceCommandApiFp(this.configuration).stopUploadInferenceResult(deviceId, grantType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightApi - axios parameter creator
 * @export
 */
export const InsightApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the URL to export the images of specified conditions in zip file format. *For encrypted images for learning in other environments  [Prerequisites] - The encryption method is public key cryptography. - A zip file containing the target images can be downloaded by accessing a URL.   Each image is encoded using the method described hereafter. - The key used for encryption is a shared key of 32 characters issued randomly by the API each time. - The image encryption method is AES128, MODE_CBC - The iv (initial vector, 16 digits) and encrypted data are stored in a zip file.  [Generating a Key] - Private keys are issued by Sier itself. - Public and private keys are issued with a length of 1024 or 2048. - The public key (key) specified to the parameter of this API passes the pem file content of the public key in a base64 encoded format.    Example: Base64 encode the entire string as follows:    -----BEGIN PUBLIC KEY-----   MIGfMA0GCSqGSIb3DQEBAQUAA4GNADC   ...   -----END PUBLIC KEY-----
         * @summary ExportImages
         * @param {string} key Public key. *Base64-encoded format of the entire pem file contents of the public key
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [fromDatetime] Date and time (From). - Format: yyyyMMddhhmm
         * @param {string} [toDatetime] Date/Time (To). - Format: yyyyMMddhhmm
         * @param {string} [deviceId] Device ID.
         * @param {string} [fileFormat] Image file format. If this is not specified, there is no filtering. - Value definition   JPG   BMP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportImages: async (key: string, grantType?: string, fromDatetime?: string, toDatetime?: string, deviceId?: string, fileFormat?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('exportImages', 'key', key)
            const localVarPath = `/devices/images/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (fromDatetime !== undefined) {
                localVarQueryParameter['from_datetime'] = fromDatetime;
            }

            if (toDatetime !== undefined) {
                localVarQueryParameter['to_datetime'] = toDatetime;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (fileFormat !== undefined) {
                localVarQueryParameter['file_format'] = fileFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the image save directory list of the devices for each device group.
         * @summary GetImageDirectories
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [deviceId] Device ID. If this is specified, return an image directory list linked to the specified device ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDirectories: async (grantType?: string, deviceId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices/images/directories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the (saved) images for a specified device. *Application: Use to display an image in a UI
         * @summary GetImages
         * @param {string} deviceId Device ID.
         * @param {string} subDirectoryName Directory name.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [orderBy] Sort order: Sorted by date image was created. Value range: DESC, ASC
         * @param {number} [numberOfImages] Number of images to fetch. Value range: 0 to 256
         * @param {number} [skip] Number of images to skip fetching.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImages: async (deviceId: string, subDirectoryName: string, grantType?: string, orderBy?: string, numberOfImages?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getImages', 'deviceId', deviceId)
            // verify required parameter 'subDirectoryName' is not null or undefined
            assertParamExists('getImages', 'subDirectoryName', subDirectoryName)
            const localVarPath = `/devices/{device_id}/images/directories/{sub_directory_name}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"sub_directory_name"}}`, encodeURIComponent(String(subDirectoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (numberOfImages !== undefined) {
                localVarQueryParameter['number_of_images'] = numberOfImages;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the (saved) inference result metadata list information for a specified device.
         * @summary GetInferenceResults
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {number} [numberOfInferenceresults] Number of cases to get. Return the latest record of the specified number of cases. *Maximum value: 10000
         * @param {string} [filter] Search filter *The specifications are the same except for those of CosmosDB UI of the Azure portal and those listed below. - A where string does not need to be added to the heading. - deviceID does not need to be added.  Example: - Filter by model ID   c.ModelID &#x3D; \&quot;0201020001790103\&quot; - Filter by Cosmos time stamp   c._ts &gt; 1606897951
         * @param {number} [raw] If 1 is specified, add a record stored to CosmosDB and return it. - Value definition   0: Do not add   1: Add
         * @param {string} [time] When this value is specified, extract the inference result metadata within the following range. - Extraction range   (time - threshold) &lt;&#x3D; T  *Time in inference result metadata &lt; (time + threshold)  - Value definition   yyyy: 4-digit year string   MM: 2-digit month string   dd: 2-digit day string   HH: 2-digit hour string   mm: 2-digit minute string   ss: 2-digit second string   fff: 3-digit millisecond string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInferenceResults: async (deviceId: string, grantType?: string, numberOfInferenceresults?: number, filter?: string, raw?: number, time?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getInferenceResults', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/inferenceresults`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (numberOfInferenceresults !== undefined) {
                localVarQueryParameter['NumberOfInferenceresults'] = numberOfInferenceresults;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightApi - functional programming interface
 * @export
 */
export const InsightApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the URL to export the images of specified conditions in zip file format. *For encrypted images for learning in other environments  [Prerequisites] - The encryption method is public key cryptography. - A zip file containing the target images can be downloaded by accessing a URL.   Each image is encoded using the method described hereafter. - The key used for encryption is a shared key of 32 characters issued randomly by the API each time. - The image encryption method is AES128, MODE_CBC - The iv (initial vector, 16 digits) and encrypted data are stored in a zip file.  [Generating a Key] - Private keys are issued by Sier itself. - Public and private keys are issued with a length of 1024 or 2048. - The public key (key) specified to the parameter of this API passes the pem file content of the public key in a base64 encoded format.    Example: Base64 encode the entire string as follows:    -----BEGIN PUBLIC KEY-----   MIGfMA0GCSqGSIb3DQEBAQUAA4GNADC   ...   -----END PUBLIC KEY-----
         * @summary ExportImages
         * @param {string} key Public key. *Base64-encoded format of the entire pem file contents of the public key
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [fromDatetime] Date and time (From). - Format: yyyyMMddhhmm
         * @param {string} [toDatetime] Date/Time (To). - Format: yyyyMMddhhmm
         * @param {string} [deviceId] Device ID.
         * @param {string} [fileFormat] Image file format. If this is not specified, there is no filtering. - Value definition   JPG   BMP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportImages(key: string, grantType?: string, fromDatetime?: string, toDatetime?: string, deviceId?: string, fileFormat?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportImages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportImages(key, grantType, fromDatetime, toDatetime, deviceId, fileFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the image save directory list of the devices for each device group.
         * @summary GetImageDirectories
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [deviceId] Device ID. If this is specified, return an image directory list linked to the specified device ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageDirectories(grantType?: string, deviceId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetImageDirectories200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageDirectories(grantType, deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the (saved) images for a specified device. *Application: Use to display an image in a UI
         * @summary GetImages
         * @param {string} deviceId Device ID.
         * @param {string} subDirectoryName Directory name.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [orderBy] Sort order: Sorted by date image was created. Value range: DESC, ASC
         * @param {number} [numberOfImages] Number of images to fetch. Value range: 0 to 256
         * @param {number} [skip] Number of images to skip fetching.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImages(deviceId: string, subDirectoryName: string, grantType?: string, orderBy?: string, numberOfImages?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetImages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImages(deviceId, subDirectoryName, grantType, orderBy, numberOfImages, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the (saved) inference result metadata list information for a specified device.
         * @summary GetInferenceResults
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {number} [numberOfInferenceresults] Number of cases to get. Return the latest record of the specified number of cases. *Maximum value: 10000
         * @param {string} [filter] Search filter *The specifications are the same except for those of CosmosDB UI of the Azure portal and those listed below. - A where string does not need to be added to the heading. - deviceID does not need to be added.  Example: - Filter by model ID   c.ModelID &#x3D; \&quot;0201020001790103\&quot; - Filter by Cosmos time stamp   c._ts &gt; 1606897951
         * @param {number} [raw] If 1 is specified, add a record stored to CosmosDB and return it. - Value definition   0: Do not add   1: Add
         * @param {string} [time] When this value is specified, extract the inference result metadata within the following range. - Extraction range   (time - threshold) &lt;&#x3D; T  *Time in inference result metadata &lt; (time + threshold)  - Value definition   yyyy: 4-digit year string   MM: 2-digit month string   dd: 2-digit day string   HH: 2-digit hour string   mm: 2-digit minute string   ss: 2-digit second string   fff: 3-digit millisecond string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInferenceResults(deviceId: string, grantType?: string, numberOfInferenceresults?: number, filter?: string, raw?: number, time?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetInferenceResults200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInferenceResults(deviceId, grantType, numberOfInferenceresults, filter, raw, time, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightApi - factory interface
 * @export
 */
export const InsightApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightApiFp(configuration)
    return {
        /**
         * Get the URL to export the images of specified conditions in zip file format. *For encrypted images for learning in other environments  [Prerequisites] - The encryption method is public key cryptography. - A zip file containing the target images can be downloaded by accessing a URL.   Each image is encoded using the method described hereafter. - The key used for encryption is a shared key of 32 characters issued randomly by the API each time. - The image encryption method is AES128, MODE_CBC - The iv (initial vector, 16 digits) and encrypted data are stored in a zip file.  [Generating a Key] - Private keys are issued by Sier itself. - Public and private keys are issued with a length of 1024 or 2048. - The public key (key) specified to the parameter of this API passes the pem file content of the public key in a base64 encoded format.    Example: Base64 encode the entire string as follows:    -----BEGIN PUBLIC KEY-----   MIGfMA0GCSqGSIb3DQEBAQUAA4GNADC   ...   -----END PUBLIC KEY-----
         * @summary ExportImages
         * @param {string} key Public key. *Base64-encoded format of the entire pem file contents of the public key
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [fromDatetime] Date and time (From). - Format: yyyyMMddhhmm
         * @param {string} [toDatetime] Date/Time (To). - Format: yyyyMMddhhmm
         * @param {string} [deviceId] Device ID.
         * @param {string} [fileFormat] Image file format. If this is not specified, there is no filtering. - Value definition   JPG   BMP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportImages(key: string, grantType?: string, fromDatetime?: string, toDatetime?: string, deviceId?: string, fileFormat?: string, options?: any): AxiosPromise<ExportImages200Response> {
            return localVarFp.exportImages(key, grantType, fromDatetime, toDatetime, deviceId, fileFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the image save directory list of the devices for each device group.
         * @summary GetImageDirectories
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [deviceId] Device ID. If this is specified, return an image directory list linked to the specified device ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDirectories(grantType?: string, deviceId?: string, options?: any): AxiosPromise<Array<GetImageDirectories200ResponseInner>> {
            return localVarFp.getImageDirectories(grantType, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the (saved) images for a specified device. *Application: Use to display an image in a UI
         * @summary GetImages
         * @param {string} deviceId Device ID.
         * @param {string} subDirectoryName Directory name.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [orderBy] Sort order: Sorted by date image was created. Value range: DESC, ASC
         * @param {number} [numberOfImages] Number of images to fetch. Value range: 0 to 256
         * @param {number} [skip] Number of images to skip fetching.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImages(deviceId: string, subDirectoryName: string, grantType?: string, orderBy?: string, numberOfImages?: number, skip?: number, options?: any): AxiosPromise<GetImages200Response> {
            return localVarFp.getImages(deviceId, subDirectoryName, grantType, orderBy, numberOfImages, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the (saved) inference result metadata list information for a specified device.
         * @summary GetInferenceResults
         * @param {string} deviceId Device ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {number} [numberOfInferenceresults] Number of cases to get. Return the latest record of the specified number of cases. *Maximum value: 10000
         * @param {string} [filter] Search filter *The specifications are the same except for those of CosmosDB UI of the Azure portal and those listed below. - A where string does not need to be added to the heading. - deviceID does not need to be added.  Example: - Filter by model ID   c.ModelID &#x3D; \&quot;0201020001790103\&quot; - Filter by Cosmos time stamp   c._ts &gt; 1606897951
         * @param {number} [raw] If 1 is specified, add a record stored to CosmosDB and return it. - Value definition   0: Do not add   1: Add
         * @param {string} [time] When this value is specified, extract the inference result metadata within the following range. - Extraction range   (time - threshold) &lt;&#x3D; T  *Time in inference result metadata &lt; (time + threshold)  - Value definition   yyyy: 4-digit year string   MM: 2-digit month string   dd: 2-digit day string   HH: 2-digit hour string   mm: 2-digit minute string   ss: 2-digit second string   fff: 3-digit millisecond string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInferenceResults(deviceId: string, grantType?: string, numberOfInferenceresults?: number, filter?: string, raw?: number, time?: string, options?: any): AxiosPromise<Array<GetInferenceResults200ResponseInner>> {
            return localVarFp.getInferenceResults(deviceId, grantType, numberOfInferenceresults, filter, raw, time, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightApi - object-oriented interface
 * @export
 * @class InsightApi
 * @extends {BaseAPI}
 */
export class InsightApi extends BaseAPI {
    /**
     * Get the URL to export the images of specified conditions in zip file format. *For encrypted images for learning in other environments  [Prerequisites] - The encryption method is public key cryptography. - A zip file containing the target images can be downloaded by accessing a URL.   Each image is encoded using the method described hereafter. - The key used for encryption is a shared key of 32 characters issued randomly by the API each time. - The image encryption method is AES128, MODE_CBC - The iv (initial vector, 16 digits) and encrypted data are stored in a zip file.  [Generating a Key] - Private keys are issued by Sier itself. - Public and private keys are issued with a length of 1024 or 2048. - The public key (key) specified to the parameter of this API passes the pem file content of the public key in a base64 encoded format.    Example: Base64 encode the entire string as follows:    -----BEGIN PUBLIC KEY-----   MIGfMA0GCSqGSIb3DQEBAQUAA4GNADC   ...   -----END PUBLIC KEY-----
     * @summary ExportImages
     * @param {string} key Public key. *Base64-encoded format of the entire pem file contents of the public key
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [fromDatetime] Date and time (From). - Format: yyyyMMddhhmm
     * @param {string} [toDatetime] Date/Time (To). - Format: yyyyMMddhhmm
     * @param {string} [deviceId] Device ID.
     * @param {string} [fileFormat] Image file format. If this is not specified, there is no filtering. - Value definition   JPG   BMP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public exportImages(key: string, grantType?: string, fromDatetime?: string, toDatetime?: string, deviceId?: string, fileFormat?: string, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).exportImages(key, grantType, fromDatetime, toDatetime, deviceId, fileFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the image save directory list of the devices for each device group.
     * @summary GetImageDirectories
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [deviceId] Device ID. If this is specified, return an image directory list linked to the specified device ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public getImageDirectories(grantType?: string, deviceId?: string, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).getImageDirectories(grantType, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the (saved) images for a specified device. *Application: Use to display an image in a UI
     * @summary GetImages
     * @param {string} deviceId Device ID.
     * @param {string} subDirectoryName Directory name.
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [orderBy] Sort order: Sorted by date image was created. Value range: DESC, ASC
     * @param {number} [numberOfImages] Number of images to fetch. Value range: 0 to 256
     * @param {number} [skip] Number of images to skip fetching.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public getImages(deviceId: string, subDirectoryName: string, grantType?: string, orderBy?: string, numberOfImages?: number, skip?: number, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).getImages(deviceId, subDirectoryName, grantType, orderBy, numberOfImages, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the (saved) inference result metadata list information for a specified device.
     * @summary GetInferenceResults
     * @param {string} deviceId Device ID.
     * @param {string} [grantType] The grant type for authentication
     * @param {number} [numberOfInferenceresults] Number of cases to get. Return the latest record of the specified number of cases. *Maximum value: 10000
     * @param {string} [filter] Search filter *The specifications are the same except for those of CosmosDB UI of the Azure portal and those listed below. - A where string does not need to be added to the heading. - deviceID does not need to be added.  Example: - Filter by model ID   c.ModelID &#x3D; \&quot;0201020001790103\&quot; - Filter by Cosmos time stamp   c._ts &gt; 1606897951
     * @param {number} [raw] If 1 is specified, add a record stored to CosmosDB and return it. - Value definition   0: Do not add   1: Add
     * @param {string} [time] When this value is specified, extract the inference result metadata within the following range. - Extraction range   (time - threshold) &lt;&#x3D; T  *Time in inference result metadata &lt; (time + threshold)  - Value definition   yyyy: 4-digit year string   MM: 2-digit month string   dd: 2-digit day string   HH: 2-digit hour string   mm: 2-digit minute string   ss: 2-digit second string   fff: 3-digit millisecond string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public getInferenceResults(deviceId: string, grantType?: string, numberOfInferenceresults?: number, filter?: string, raw?: number, time?: string, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).getInferenceResults(deviceId, grantType, numberOfInferenceresults, filter, raw, time, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManageDevicesApi - axios parameter creator
 * @export
 */
export const ManageDevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the device list information.
         * @summary GetDevices
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [connectionState] Connection state. - Value definition   Connected   Disconnected
         * @param {string} [deviceName] Device name. *Partial match search
         * @param {string} [deviceId] Device ID. *Partial match search
         * @param {string} [deviceGroupId] Device group ID.
         * @param {string} [deviceIds] Specify multiple device IDs separated by commas.
         * @param {string} [scope] Specify the scope of response parameters to return.  - Value definition   full : Return full parameters   minimal : Return minimal parameters *fast response speed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (grantType?: string, connectionState?: string, deviceName?: string, deviceId?: string, deviceGroupId?: string, deviceIds?: string, scope?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (connectionState !== undefined) {
                localVarQueryParameter['connectionState'] = connectionState;
            }

            if (deviceName !== undefined) {
                localVarQueryParameter['device_name'] = deviceName;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (deviceGroupId !== undefined) {
                localVarQueryParameter['device_group_id'] = deviceGroupId;
            }

            if (deviceIds !== undefined) {
                localVarQueryParameter['device_ids'] = deviceIds;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageDevicesApi - functional programming interface
 * @export
 */
export const ManageDevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageDevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the device list information.
         * @summary GetDevices
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [connectionState] Connection state. - Value definition   Connected   Disconnected
         * @param {string} [deviceName] Device name. *Partial match search
         * @param {string} [deviceId] Device ID. *Partial match search
         * @param {string} [deviceGroupId] Device group ID.
         * @param {string} [deviceIds] Specify multiple device IDs separated by commas.
         * @param {string} [scope] Specify the scope of response parameters to return.  - Value definition   full : Return full parameters   minimal : Return minimal parameters *fast response speed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(grantType?: string, connectionState?: string, deviceName?: string, deviceId?: string, deviceGroupId?: string, deviceIds?: string, scope?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDevices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(grantType, connectionState, deviceName, deviceId, deviceGroupId, deviceIds, scope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManageDevicesApi - factory interface
 * @export
 */
export const ManageDevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageDevicesApiFp(configuration)
    return {
        /**
         * Get the device list information.
         * @summary GetDevices
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [connectionState] Connection state. - Value definition   Connected   Disconnected
         * @param {string} [deviceName] Device name. *Partial match search
         * @param {string} [deviceId] Device ID. *Partial match search
         * @param {string} [deviceGroupId] Device group ID.
         * @param {string} [deviceIds] Specify multiple device IDs separated by commas.
         * @param {string} [scope] Specify the scope of response parameters to return.  - Value definition   full : Return full parameters   minimal : Return minimal parameters *fast response speed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(grantType?: string, connectionState?: string, deviceName?: string, deviceId?: string, deviceGroupId?: string, deviceIds?: string, scope?: string, options?: any): AxiosPromise<GetDevices200Response> {
            return localVarFp.getDevices(grantType, connectionState, deviceName, deviceId, deviceGroupId, deviceIds, scope, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageDevicesApi - object-oriented interface
 * @export
 * @class ManageDevicesApi
 * @extends {BaseAPI}
 */
export class ManageDevicesApi extends BaseAPI {
    /**
     * Get the device list information.
     * @summary GetDevices
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [connectionState] Connection state. - Value definition   Connected   Disconnected
     * @param {string} [deviceName] Device name. *Partial match search
     * @param {string} [deviceId] Device ID. *Partial match search
     * @param {string} [deviceGroupId] Device group ID.
     * @param {string} [deviceIds] Specify multiple device IDs separated by commas.
     * @param {string} [scope] Specify the scope of response parameters to return.  - Value definition   full : Return full parameters   minimal : Return minimal parameters *fast response speed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageDevicesApi
     */
    public getDevices(grantType?: string, connectionState?: string, deviceName?: string, deviceId?: string, deviceGroupId?: string, deviceIds?: string, scope?: string, options?: AxiosRequestConfig) {
        return ManageDevicesApiFp(this.configuration).getDevices(grantType, connectionState, deviceName, deviceId, deviceGroupId, deviceIds, scope, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrainModelApi - axios parameter creator
 * @export
 */
export const TrainModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the base model, device model, and project associated with the specified model ID.
         * @summary DeleteModel
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: async (modelId: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('deleteModel', 'modelId', modelId)
            const localVarPath = `/models/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified base model information.
         * @summary GetBaseModelStatus
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [latestType] Latest version type.. - Value definition   0: Latest published version   1: Latest version (latest including model version being converted/published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseModelStatus: async (modelId: string, grantType?: string, latestType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getBaseModelStatus', 'modelId', modelId)
            const localVarPath = `/models/{model_id}/base`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (latestType !== undefined) {
                localVarQueryParameter['latest_type'] = latestType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the model list information.
         * @summary GetModels
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [modelId] Model ID. *Partial match search
         * @param {string} [comment] Model description. *Partial match search
         * @param {string} [projectName] Project name. *Partial match search
         * @param {string} [modelPlatform] Model Platform. - Value definition   0 : Custom Vision   1 : Non Custom Vision
         * @param {string} [projectType] Project Type. - Value definition   0 : Base model   1 : Device model
         * @param {string} [deviceId] Device Id.
         * @param {string} [latestType] Latest version type.. - Value definition   0: Latest published version   1: Latest version (latest including model version being converted/published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels: async (grantType?: string, modelId?: string, comment?: string, projectName?: string, modelPlatform?: string, projectType?: string, deviceId?: string, latestType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (modelId !== undefined) {
                localVarQueryParameter['model_id'] = modelId;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (projectName !== undefined) {
                localVarQueryParameter['project_name'] = projectName;
            }

            if (modelPlatform !== undefined) {
                localVarQueryParameter['model_platform'] = modelPlatform;
            }

            if (projectType !== undefined) {
                localVarQueryParameter['project_type'] = projectType;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (latestType !== undefined) {
                localVarQueryParameter['latest_type'] = latestType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import the base model. In addition, in the case of a new model ID, it is newly saved. If you specify a model ID that has already been registered in the system, the version will be upgraded.
         * @summary ImportBaseModel
         * @param {ImportBaseModelJsonBody} importBaseModelJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBaseModel: async (importBaseModelJsonBody: ImportBaseModelJsonBody, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importBaseModelJsonBody' is not null or undefined
            assertParamExists('importBaseModel', 'importBaseModelJsonBody', importBaseModelJsonBody)
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importBaseModelJsonBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a function to publish a conversion model. As model publishing takes time, this is performed asynchronously. *Check the processing status in the result of the GetBaseModelStatus API or GetDeviceModelStatus API response. If the result is \'Import completed\', the process is completed.
         * @summary PublishModel
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [deviceId] Device ID *Specify this when the device model is the target. Do not specify this when the base model is the target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishModel: async (modelId: string, grantType?: string, deviceId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('publishModel', 'modelId', modelId)
            const localVarPath = `/models/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrainModelApi - functional programming interface
 * @export
 */
export const TrainModelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrainModelApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the base model, device model, and project associated with the specified model ID.
         * @summary DeleteModel
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModel(modelId: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModel(modelId, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the specified base model information.
         * @summary GetBaseModelStatus
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [latestType] Latest version type.. - Value definition   0: Latest published version   1: Latest version (latest including model version being converted/published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBaseModelStatus(modelId: string, grantType?: string, latestType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBaseModelStatus(modelId, grantType, latestType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the model list information.
         * @summary GetModels
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [modelId] Model ID. *Partial match search
         * @param {string} [comment] Model description. *Partial match search
         * @param {string} [projectName] Project name. *Partial match search
         * @param {string} [modelPlatform] Model Platform. - Value definition   0 : Custom Vision   1 : Non Custom Vision
         * @param {string} [projectType] Project Type. - Value definition   0 : Base model   1 : Device model
         * @param {string} [deviceId] Device Id.
         * @param {string} [latestType] Latest version type.. - Value definition   0: Latest published version   1: Latest version (latest including model version being converted/published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModels(grantType?: string, modelId?: string, comment?: string, projectName?: string, modelPlatform?: string, projectType?: string, deviceId?: string, latestType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetModels200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModels(grantType, modelId, comment, projectName, modelPlatform, projectType, deviceId, latestType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import the base model. In addition, in the case of a new model ID, it is newly saved. If you specify a model ID that has already been registered in the system, the version will be upgraded.
         * @summary ImportBaseModel
         * @param {ImportBaseModelJsonBody} importBaseModelJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importBaseModel(importBaseModelJsonBody: ImportBaseModelJsonBody, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importBaseModel(importBaseModelJsonBody, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide a function to publish a conversion model. As model publishing takes time, this is performed asynchronously. *Check the processing status in the result of the GetBaseModelStatus API or GetDeviceModelStatus API response. If the result is \'Import completed\', the process is completed.
         * @summary PublishModel
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [deviceId] Device ID *Specify this when the device model is the target. Do not specify this when the base model is the target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishModel(modelId: string, grantType?: string, deviceId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishModel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishModel(modelId, grantType, deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrainModelApi - factory interface
 * @export
 */
export const TrainModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrainModelApiFp(configuration)
    return {
        /**
         * Deletes the base model, device model, and project associated with the specified model ID.
         * @summary DeleteModel
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(modelId: string, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteModel(modelId, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the specified base model information.
         * @summary GetBaseModelStatus
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [latestType] Latest version type.. - Value definition   0: Latest published version   1: Latest version (latest including model version being converted/published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseModelStatus(modelId: string, grantType?: string, latestType?: string, options?: any): AxiosPromise<ModelInfo> {
            return localVarFp.getBaseModelStatus(modelId, grantType, latestType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the model list information.
         * @summary GetModels
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [modelId] Model ID. *Partial match search
         * @param {string} [comment] Model description. *Partial match search
         * @param {string} [projectName] Project name. *Partial match search
         * @param {string} [modelPlatform] Model Platform. - Value definition   0 : Custom Vision   1 : Non Custom Vision
         * @param {string} [projectType] Project Type. - Value definition   0 : Base model   1 : Device model
         * @param {string} [deviceId] Device Id.
         * @param {string} [latestType] Latest version type.. - Value definition   0: Latest published version   1: Latest version (latest including model version being converted/published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels(grantType?: string, modelId?: string, comment?: string, projectName?: string, modelPlatform?: string, projectType?: string, deviceId?: string, latestType?: string, options?: any): AxiosPromise<GetModels200Response> {
            return localVarFp.getModels(grantType, modelId, comment, projectName, modelPlatform, projectType, deviceId, latestType, options).then((request) => request(axios, basePath));
        },
        /**
         * Import the base model. In addition, in the case of a new model ID, it is newly saved. If you specify a model ID that has already been registered in the system, the version will be upgraded.
         * @summary ImportBaseModel
         * @param {ImportBaseModelJsonBody} importBaseModelJsonBody 
         * @param {string} [grantType] The grant type for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBaseModel(importBaseModelJsonBody: ImportBaseModelJsonBody, grantType?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.importBaseModel(importBaseModelJsonBody, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide a function to publish a conversion model. As model publishing takes time, this is performed asynchronously. *Check the processing status in the result of the GetBaseModelStatus API or GetDeviceModelStatus API response. If the result is \'Import completed\', the process is completed.
         * @summary PublishModel
         * @param {string} modelId Model ID.
         * @param {string} [grantType] The grant type for authentication
         * @param {string} [deviceId] Device ID *Specify this when the device model is the target. Do not specify this when the base model is the target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishModel(modelId: string, grantType?: string, deviceId?: string, options?: any): AxiosPromise<PublishModel200Response> {
            return localVarFp.publishModel(modelId, grantType, deviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrainModelApi - object-oriented interface
 * @export
 * @class TrainModelApi
 * @extends {BaseAPI}
 */
export class TrainModelApi extends BaseAPI {
    /**
     * Deletes the base model, device model, and project associated with the specified model ID.
     * @summary DeleteModel
     * @param {string} modelId Model ID.
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainModelApi
     */
    public deleteModel(modelId: string, grantType?: string, options?: AxiosRequestConfig) {
        return TrainModelApiFp(this.configuration).deleteModel(modelId, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the specified base model information.
     * @summary GetBaseModelStatus
     * @param {string} modelId Model ID.
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [latestType] Latest version type.. - Value definition   0: Latest published version   1: Latest version (latest including model version being converted/published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainModelApi
     */
    public getBaseModelStatus(modelId: string, grantType?: string, latestType?: string, options?: AxiosRequestConfig) {
        return TrainModelApiFp(this.configuration).getBaseModelStatus(modelId, grantType, latestType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the model list information.
     * @summary GetModels
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [modelId] Model ID. *Partial match search
     * @param {string} [comment] Model description. *Partial match search
     * @param {string} [projectName] Project name. *Partial match search
     * @param {string} [modelPlatform] Model Platform. - Value definition   0 : Custom Vision   1 : Non Custom Vision
     * @param {string} [projectType] Project Type. - Value definition   0 : Base model   1 : Device model
     * @param {string} [deviceId] Device Id.
     * @param {string} [latestType] Latest version type.. - Value definition   0: Latest published version   1: Latest version (latest including model version being converted/published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainModelApi
     */
    public getModels(grantType?: string, modelId?: string, comment?: string, projectName?: string, modelPlatform?: string, projectType?: string, deviceId?: string, latestType?: string, options?: AxiosRequestConfig) {
        return TrainModelApiFp(this.configuration).getModels(grantType, modelId, comment, projectName, modelPlatform, projectType, deviceId, latestType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import the base model. In addition, in the case of a new model ID, it is newly saved. If you specify a model ID that has already been registered in the system, the version will be upgraded.
     * @summary ImportBaseModel
     * @param {ImportBaseModelJsonBody} importBaseModelJsonBody 
     * @param {string} [grantType] The grant type for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainModelApi
     */
    public importBaseModel(importBaseModelJsonBody: ImportBaseModelJsonBody, grantType?: string, options?: AxiosRequestConfig) {
        return TrainModelApiFp(this.configuration).importBaseModel(importBaseModelJsonBody, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide a function to publish a conversion model. As model publishing takes time, this is performed asynchronously. *Check the processing status in the result of the GetBaseModelStatus API or GetDeviceModelStatus API response. If the result is \'Import completed\', the process is completed.
     * @summary PublishModel
     * @param {string} modelId Model ID.
     * @param {string} [grantType] The grant type for authentication
     * @param {string} [deviceId] Device ID *Specify this when the device model is the target. Do not specify this when the base model is the target.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainModelApi
     */
    public publishModel(modelId: string, grantType?: string, deviceId?: string, options?: AxiosRequestConfig) {
        return TrainModelApiFp(this.configuration).publishModel(modelId, grantType, deviceId, options).then((request) => request(this.axios, this.basePath));
    }
}


